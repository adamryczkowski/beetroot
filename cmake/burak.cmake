# get_target(<TEMPLATE_NAME> [PATH <Ścieżka do targets.cmake>] <Args...>)
#
# High level function responsible for 
# 1. finding a target defining function by its template name (or path), 
# 2. get all its arguments by properly combining default values with already existing variables and arguments Args...
# 3. if target defined by that arguments exists already, return its name, otherwise...
# 3. ...instatiate its dependencies (which may be internal and external) by calling declare_dependencies(), 
# 4. define the target by calling generate_targets() and
# 5. return the actual target name.
#

get_filename_component(__PREFIX "${CMAKE_CURRENT_LIST_FILE}" DIRECTORY)
set(CMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY 1) #We disable use of CMake package registry. See https://cmake.org/cmake/help/v3.2/variable/CMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY.html . With this variable set, the only version of the packages will be the version we actually intend to use.

include(${__PREFIX}/burak_get_target.cmake)
include(${__PREFIX}/burak_finalize.cmake)
include(${__PREFIX}/burak_variables.cmake)
include(${__PREFIX}/burak_global_storage.cmake)
include(${__PREFIX}/burak_global_storage_misc.cmake)
include(${__PREFIX}/burak_dependency_processing.cmake)
include(${__PREFIX}/burak_external_target.cmake)
include(${__PREFIX}/build_install_prefix.cmake)
include(${__PREFIX}/set_operations.cmake)
include(${__PREFIX}/prepare_arguments_to_pass.cmake)
include(${__PREFIX}/missing_dependency.cmake)

_set_behavior_outside_defining_targets()
if(NOT __NOT_SUPERBUILD)
	set_property(GLOBAL PROPERTY __BURAK_EXTERNAL_DEPENDENCIES "")
else()
	message(STATUS "Beginning of the second phase")
endif()
set(__RANDOM ${__RANDOM})
include(ExternalProject)

#We hijack the project() command to make sure, that during the superbuild phase no actual compiling will take place.
macro(project) 
	if(__NOT_SUPERBUILD)
		_project(${ARGN})
	else()
		message("No languages in project ${ARGV0}")
		_project(${ARGV0} NONE)
	endif()
endmacro()

function(_invoke_apply_dependency_to_target __DEPENDEE_INSTANCE_ID __INSTANCE_ID __OUT_FUNCTION_EXISTS)
	_retrieve_instance_data(${__INSTANCE_ID} PATH __TARGETS_CMAKE_PATH)
	_retrieve_instance_args(${__INSTANCE_ID} MODIFIERS __ARGS)
	set(__TMP_LIST "${__ARGS__LIST}")
	_retrieve_instance_args(${__INSTANCE_ID} I_FEATURES __ARGS)
	list(APPEND __TMP_LIST ${__ARGS__LIST})
	_retrieve_instance_args(${__INSTANCE_ID} LINKPARS __ARGS)
	list(APPEND __TMP_LIST ${__ARGS__LIST})
	set(__ARGS__LIST ${__TMP_LIST})
	_make_instance_name(${__DEPENDEE_INSTANCE_ID} __DEP_INSTANCE_NAME)
	_make_instance_name(${__INSTANCE_ID} __INSTANCE_NAME)
	
	_read_functions_from_targets_file("${__TARGETS_CMAKE_PATH}")
	_instantiate_variables(__ARGS "${__ARGS__LIST}")
	unset(__NO_OP)
#	apply_to_target(${__DEPENDEE_INSTANCE_ID} ${__INSTANCE_NAME})
#	take_dependency_from_target(${__DEPENDEE_INSTANCE_ID} ${__INSTANCE_NAME})

	get_target_property(__TYPE ${__DEP_INSTANCE_NAME} TYPE)
	if("${__TYPE}" STREQUAL "INTERFACE_LIBRARY" )
		set(KEYWORD "INTERFACE")
	else()
		set(KEYWORD "PUBLIC")
	endif()


	apply_dependency_to_target(${__DEP_INSTANCE_NAME} ${__INSTANCE_NAME})

#	message(STATUS "_invoke_apply_dependency_to_target(): __TARGETS_CMAKE_PATH: ${__TARGETS_CMAKE_PATH} __DEPENDEE_INSTANCE_ID: ${__DEPENDEE_INSTANCE_ID} __INSTANCE_ID: ${__INSTANCE_ID} __NO_OP: ${__NO_OP}")
	if(__NO_OP)
		set(${__OUT_FUNCTION_EXISTS} 0 PARENT_SCOPE)
	else()
		set(${__OUT_FUNCTION_EXISTS} 1 PARENT_SCOPE)
	endif()
endfunction()

function(_make_sure_no_apply_to_target __TARGETS_CMAKE_PATH __DEPENDENT __DEPENDEE)
	_read_functions_from_targets_file("${__TARGETS_CMAKE_PATH}")
	unset(__NO_OP)
	apply_to_target("NO_TARGET" "NO_TARGET")
	if(NOT __NO_OP)
		message(FATAL_ERROR "Cannot use ${__DEPENDENT} as a dependency of ${__DEPENDEE}, because ${__DEPENDENT} has take_dependency_from_target() function defined which cannot be called when ${__DEPENDEE} does not generate a target.")
	endif()
endfunction()

#Calls targets.cmake:generate_targets() to create the declared target during the project phase run of the CMake. 
#Does nothing on the SUPERBUILD phase, as the internal project dependencies are of no concern then.
function(_get_target_internal __INSTANCE_ID __OUT_FUNCTION_EXISTS)
#	message(STATUS "Inside _get_target_internal trying to instantiate ${__INSTANCE_NAME}")
	if(NOT __NOT_SUPERBUILD)
		return()
	endif()
	_retrieve_instance_data(${__INSTANCE_ID} I_TEMPLATE_NAME __TEMPLATE_NAME)
	_make_instance_name(${__INSTANCE_ID} __INSTANCE_NAME)
	_retrieve_instance_data(${__INSTANCE_ID} PATH __TARGETS_CMAKE_PATH)

	_retrieve_instance_args(${__INSTANCE_ID} I_FEATURES __ARGS)
	set(__ARGS__LIST_FEATURES "${__ARGS__LIST}")
	_retrieve_instance_args(${__INSTANCE_ID} MODIFIERS __ARGS)
	set(__ARGS__LIST_MODIFIERS "${__ARGS__LIST}")
	list(APPEND __ARGS__LIST ${__ARGS__LIST_FEATURES})
	
	_retrieve_instance_data(${__INSTANCE_ID} DEP_INSTANCES __DEP_ID_LIST)
	
	if(NOT __TARGETS_CMAKE_PATH)
		message(FATAL_ERROR "Internal error: Empty __TARGETS_CMAKE_PATH")
	endif()
	
	#We need to populate all dependencies, so their names can be used in the targets.cmake
	set(__DEP_EXPVAR_LIST)
	if(__DEP_ID_LIST)
		foreach(__DEP_ID IN LISTS __DEP_ID_LIST)
			_make_instance_name(${__DEP_ID} __DEP_NAME)
			_retrieve_instance_data(${__DEP_ID} I_TEMPLATE_NAME __DEP_TEMPLATE_NAME)
			string(REPLACE "::" "_" __DEP_TEMPLATE_NAME "${__DEP_TEMPLATE_NAME}")
		
			list(APPEND ${__DEP_TEMPLATE_NAME}_TARGET_NAME "${__DEP_NAME}")
			_retrieve_instance_data(${__DEP_ID} EXPORTED_VARS __EXPORTED_VARS)
			_retrieve_instance_data(${__DEP_ID} SOURCE_DIR __DEP_SOURCE_DIR)
			if(__DEP_SOURCE_DIR)
				list(APPEND __EXPORTED_VARS ${__DEP_TEMPLATE_NAME}_SOURCE_DIR)
				set(${__DEP_TEMPLATE_NAME}_SOURCE_DIR "${__DEP_SOURCE_DIR}")
#				message(STATUS "_get_target_internal(): ${__DEP_TEMPLATE_NAME}_SOURCE_DIR: ${__DEP_SOURCE_DIR}")
			endif()
			_retrieve_instance_data(${__DEP_ID} INSTALL_DIR __DEP_INSTALL_DIR)
			if(__DEP_INSTALL_DIR)
				list(APPEND __EXPORTED_VARS ${__DEP_TEMPLATE_NAME}_INSTALL_DIR)
				set(${__DEP_TEMPLATE_NAME}_INSTALL_DIR "${__DEP_INSTALL_DIR}")
#				message(STATUS "_get_target_internal() ${__DEP_TEMPLATE_NAME}_INSTALL_DIR: ${__DEP_INSTALL_DIR}")
			endif()
			if(__EXPORTED_VARS)
#				message(STATUS "_get_target_internal() __EXPORTED_VARS: ${__EXPORTED_VARS}: ${Serialbox_SerialboxCStatic_INSTALL_DIR}")
				_retrieve_instance_args(${__DEP_ID} LINKPARS  __DEPVARS)
				_retrieve_instance_args(${__DEP_ID} I_FEATURES  __DEPVARS)
				_retrieve_instance_args(${__DEP_ID} MODIFIERS __DEPVARS)
				foreach(__EXPVAR IN LISTS __EXPORTED_VARS)
					if("${__EXPVAR}" IN_LIST __ARGS__LIST)
						_get_nice_name(${__DEP_ID} __NICE_NAME_DEP)
						_get_nice_name(${__INSTANCE_ID} __NICE_NAME_WE)
						message(WARNING "Exported variable ${__EXPVAR} from ${__NICE_NAME_DEP} will not be available in ${__NICE_NAME_WE} because it is shadowed by the variable of the same name declared in it.")
					elseif("${__EXPVAR}" IN_LIST __DEP_EXPVAR_LIST AND NOT "${__EXPVAR}" STREQUAL "${__DEPVARS_${__EXPVAR}}")
						_get_nice_name(${__DEP_ID} __NICE_NAME_DEP)
						_get_nice_name(${__INSTANCE_ID} __NICE_NAME_WE)
						_retrieve_instance_args(${__DEP_ID} PATH __DEPPATH)
						file(RELATIVE_PATH __DEPPATH ${SUPERBUILD_ROOT} "${__DEPPATH}")

						message(FATAL_ERROR "Variable ${__EXPVAR}= \"${__DEPVARS_${__EXPVAR}}\" exported from ${__NICE_NAME_DEP} has already been imported from other dependency, but with different value: \"${__EXPVAR}\". Remove this variable from the list of exported variables in ${__DEPPATH} or make sure they all have the same value.")
					else()
						if(NOT "${__EXPVAR}" STREQUAL "${__DEP_TEMPLATE_NAME}_SOURCE_DIR" AND NOT "${__EXPVAR}" STREQUAL "${__DEP_TEMPLATE_NAME}_INSTALL_DIR")
							set(${__EXPVAR} "${__DEPVARS_${__EXPVAR}}")
						endif()
						list(APPEND __DEP_EXPVAR_LIST ${__EXPVAR})
					endif()
#					message(STATUS "_get_target_internal()0 __DEP_ID: ${__DEP_ID} __EXPVAR: ${__EXPVAR}:${${__EXPVAR}} Serialbox_SerialboxCStatic_INSTALL_DIR: ${Serialbox_SerialboxCStatic_INSTALL_DIR}")

				endforeach()
			endif()
		endforeach()
	endif()
	
#	message(STATUS "_get_target_internal()1 Serialbox_SerialboxCStatic_INSTALL_DIR: ${Serialbox_SerialboxCStatic_INSTALL_DIR}")
	set(TARGET_NAME ${__INSTANCE_NAME})
	set(${__TEMPLATE_NAME}_TARGET_NAME ${__INSTANCE_NAME})
	_instantiate_variables(__ARGS "${__ARGS__LIST}")
#	message(STATUS "_get_target_internal()2 Serialbox_SerialboxCStatic_INSTALL_DIR: ${Serialbox_SerialboxCStatic_INSTALL_DIR}")
	get_filename_component(__TEMPLATE_DIR "${__TARGETS_CMAKE_PATH}" DIRECTORY)
	_read_functions_from_targets_file("${__TARGETS_CMAKE_PATH}")
#	message(STATUS "_get_target_internal()3 Serialbox_SerialboxCStatic_INSTALL_DIR: ${Serialbox_SerialboxCStatic_INSTALL_DIR}")
	
	set(CMAKE_CURRENT_SOURCE_DIR "${__TEMPLATE_DIR}")
	
#	message(FATAL_ERROR "Going to call generate targets for ${__TEMPLATE_NAME} from ${__TARGETS_CMAKE_PATH} with instance name set as «${__INSTANCE_NAME}» ")
	unset(__NO_OP)

	generate_targets(${__TEMPLATE_NAME})
	_retrieve_instance_data(${__INSTANCE_ID} NO_TARGETS __NO_TARGETS )
	_retrieve_instance_data(${__INSTANCE_ID} TARGETS_REQUIRED __TARGETS_REQUIRED )
	if(__NO_OP)
		_get_target_behavior(__TARGET_BEHAVIOR)
		if("${__TARGET_BEHAVIOR}" STREQUAL "OUTSIDE_SCOPE")
			message(FATAL_ERROR "File ${CMAKE_CURRENT_SOURCE_DIR}/targets.cmake did not define generate_targets() function.")
		endif()
		if(__TARGETS_REQUIRED)
			message(FATAL_ERROR "File ${CMAKE_CURRENT_SOURCE_DIR}/targets.cmake did not define generate_targets() function. If you cannot produce targets, please add NO_TARGETS option to TEMPLATE_OPTIONS variable defined in this file.")
		endif()
		set(${__OUT_FUNCTION_EXISTS} 0 PARENT_SCOPE)
	else()
		if(__NO_TARGETS)
			message(FATAL_ERRLR "File ${CMAKE_CURRENT_SOURCE_DIR}/targets.cmake defined generate_targets() function while also declared NO_TARGETS option.")
		endif()
		if(__TARGETS_REQUIRED AND NOT TARGET "${${__TEMPLATE_NAME}_TARGET_NAME}")
			message(FATAL_ERROR "Called ${__TEMPLATE_DIR}/targets.cmake:generate_targets(${__TEMPLATE_NAME}) which did not produce the target with name TARGET_NAME = \"${TARGET_NAME}\"" )
		endif()
		set(${__OUT_FUNCTION_EXISTS} 1 PARENT_SCOPE)
	endif()
endfunction()


function(_read_functions_from_targets_file __TARGETS_CMAKE_PATH)
	get_property(__LAST_READ_FILE GLOBAL PROPERTY __BURAK_LAST_READ_FILE)
	if(NOT "${__LAST_READ_FILE}" STREQUAL "${__TARGETS_CMAKE_PATH}")
		_read_targets_file("${__TARGETS_CMAKE_PATH}" __DUMMY __DUMMY2)
	endif()
endfunction()


# The function that actually reads in the targets.cmake file. All read variables are stored in parent scope with ${__OUT_READ_PREFIX} prefix.
# In case last optional argument is NOT present ENUM_TEMPLATES from ENUM_TARGETS are prepended with "*" character.
function(_read_targets_file __TARGETS_CMAKE_PATH __OUT_READ_PREFIX __OUT_IS_TARGET_FIXED)

	get_filename_component(__TARGETS_CMAKE_DIR "${__TARGETS_CMAKE_PATH}" DIRECTORY)
	set(CMAKE_CURRENT_SOURCE_DIR "${__TARGETS_CMAKE_DIR}")
#	set(__TARGETS_CMAKE_PATH "${__TARGETS_CMAKE_DIR}/targets.cmake")
	function(declare_dependencies DUMMY_VAR)
		#nothing to declare
	endfunction()
	
	function(generate_targets DUMMY_VAR)
		set(__NO_OP 1 PARENT_SCOPE) #To signal the caller, that the function in fact was not defined
	endfunction()
	function(apply_dependency_to_target INSTANCE_NAME DEP_INSTANCE_NAME)
#		target_link_libraries(${INSTANCE_NAME} ${DEP_INSTANCE_NAME})  <- For dependencies that do not define targets this call does not make sense.
		set(__NO_OP 1 PARENT_SCOPE) #To signal the caller, that the function in fact was not defined, only the default version was used
#		message(STATUS "default apply_to_target(): calling with INSTANCE_NAME: ${INSTANCE_NAME} and DEP_INSTANCE_NAME: ${DEP_INSTANCE_NAME}")
	endfunction()

	unset(LINK_PARAMETERS)
	unset(TARGET_PARAMETERS)
	unset(TARGET_FEATURES)
	unset(ENUM_TEMPLATES)
	unset(ENUM_TARGETS)
	unset(DEFINE_EXTERNAL_PROJECT)
	
#	message(STATUS "_read_targets_file(): Reading in ${__TARGETS_CMAKE_PATH}...")
	include(${__TARGETS_CMAKE_PATH} OPTIONAL RESULT_VARIABLE __FILE_LOADED)
	if("${__FILE_LOADED}" STREQUAL "NOTFOUND")
		message(FATAL_ERROR "Cannot find targets.cmake in ${__TARGETS_CMAKE_PATH}")
	endif()
	if(NOT DEFINED ENUM_TEMPLATES AND NOT DEFINED ENUM_TARGETS)
		message(FATAL_ERROR "You must define either ENUM_TEMPLATES or ENUM_TARGETS in ${__TARGETS_CMAKE_PATH}")
	endif()
	if(DEFINED ENUM_TEMPLATES AND DEFINED ENUM_TARGETS)
		message(FATAL_ERROR "You cannot define both ENUM_TEMPLATES and ENUM_TARGETS in ${__TARGETS_CMAKE_PATH}")
	endif()
	if(DEFINED ENUM_TARGETS)
		set(${__OUT_IS_TARGET_FIXED} 1 PARENT_SCOPE)
		set(ENUM_TEMPLATES ${ENUM_TARGETS})
	else()
		set(${__OUT_IS_TARGET_FIXED} 0 PARENT_SCOPE)
	endif()
	if(__OUT_READ_PREFIX)
		set(${__OUT_READ_PREFIX}_LINK_PARAMETERS "${LINK_PARAMETERS}" PARENT_SCOPE)
		set(${__OUT_READ_PREFIX}_TARGET_PARAMETERS "${TARGET_PARAMETERS}" PARENT_SCOPE)
		set(${__OUT_READ_PREFIX}_TARGET_FEATURES "${TARGET_FEATURES}" PARENT_SCOPE)
		set(${__OUT_READ_PREFIX}_ENUM_TEMPLATES "${ENUM_TEMPLATES}" PARENT_SCOPE)
		set(${__OUT_READ_PREFIX}_DEFINE_EXTERNAL_PROJECT "${DEFINE_EXTERNAL_PROJECT}" PARENT_SCOPE)
		if(TEMPLATE_OPTIONS)
#			message(STATUS "_read_targets_file(): TEMPLATE_OPTIONS: ${TEMPLATE_OPTIONS}")
		endif()
		set(${__OUT_READ_PREFIX}_TEMPLATE_OPTIONS "${TEMPLATE_OPTIONS}" PARENT_SCOPE)
	endif()
	set_property(GLOBAL PROPERTY __BURAK_LAST_READ_FILE "${__TARGETS_CMAKE_PATH}")
endfunction()

function(__append_target_from __TARGETS_CMAKE_PATH __EXISTING_TEMPLATES)
	set(__TEMPLATE_FILENAME "${SUPERBUILD_ROOT}/build/templates.cmake")
	_read_targets_file("${__TARGETS_CMAKE_PATH}" __TARGETS_VARS_PREFIX __IS_TARGET_FIXED)
	set(__TEMPLATES__LIST "${${__EXISTING_TEMPLATES}}")
	foreach(__TARGET IN LISTS __TARGETS_VARS_PREFIX_ENUM_TEMPLATES)
#				string(REGEX REPLACE "^\\*" "" __TARGET "${__TEMPLATE}") #removes "*" in front of fixed targets
		string(REPLACE "::" "_" __TARGET_FIXED "${__TARGET}")
		string(REPLACE "-" "_" __TARGET_FIXED "${__TARGET_FIXED}")
		if("${__TARGET_FIXED}" IN_LIST ${__EXISTING_TEMPLATES})
			message(FATAL_ERROR "Duplicate template name detected. One instance declared in ${${__EXISTING_TEMPLATES}_${__TARGET_FIXED}} and the other in ${__TARGETS_CMAKE_PATH}")
		endif()
		list(APPEND __TEMPLATES__LIST "${__TARGET_FIXED}")
		set(${__EXISTING_TEMPLATES}_TEMPLATES_${__TARGET_FIXED} "${__TARGETS_CMAKE_PATH}" PARENT_SCOPE)
#				message(STATUS "__prepare_template_list(): Found ${__TARGET_FIXED}.")
		set(__STR_OUT "set(__TEMPLATES_${__TARGET_FIXED} \"${__TARGETS_CMAKE_PATH}\" PARENT_SCOPE)\n")
		file(APPEND ${__TEMPLATE_FILENAME} __STR_OUT)
	endforeach()
endfunction()

function(__prepare_template_list)
	set(__TEMPLATE_FILENAME "${SUPERBUILD_ROOT}/build/templates.cmake")
	if(EXISTS "${__TEMPLATE_FILENAME}" AND FALSE)
		include("${__TEMPLATE_FILENAME}")
	else()
		if(EXISTS "${__TEMPLATE_FILENAME}" AND FALSE)
			file(REMOVE "${__TEMPLATE_FILENAME}")
		endif()
		set(__TEMPLATES__LIST)
		file(GLOB_RECURSE __EXTERNAL_TARGETS_DIRS_LIST LIST_DIRECTORIES "${SUPERBUILD_ROOT}/*/cmake/targets")
		foreach(__EXTERNAL_TARGETS_DIR IN LISTS __EXTERNAL_TARGETS_DIRS_LIST)
			if(IS_DIRECTORY "${__EXTERNAL_TARGETS_DIR}")
				file(GLOB_RECURSE __EXTERNAL_TARGETS_CMAKE_LIST CONFIGURE_DEPENDS "${__EXTERNAL_TARGETS_DIR}/*.cmake")
				foreach(__FILE IN LISTS __EXTERNAL_TARGETS_CMAKE_LIST)
					__append_target_from("${__FILE}" __TEMPLATES__LIST)
				endforeach()
			endif()
		endforeach()
		
		file(GLOB_RECURSE __TARGETS_CMAKE_LIST CONFIGURE_DEPENDS "${SUPERBUILD_ROOT}/targets.cmake")
		foreach(__FILE IN LISTS __TARGETS_CMAKE_LIST)
			__append_target_from("${__FILE}" __TEMPLATES__LIST)
		endforeach()
		string(REPLACE ";" " " __TEMPLATES_SPACES "${__TEMPLATES__LIST}")
#		message(STATUS "__prepare_template_list(): __STR_OUT: ${__STR_OUT}")
		set(__STR_OUT "set(__TEMPLATES__LIST ${__TEMPLATES_SPACES} PARENT_SCOPE)\n")
#		message(STATUS "__prepare_template_list(): __STR_OUT: ${__STR_OUT}")
		file(APPEND ${SUPERBUILD_ROOT}/build/templates.cmake "${__STR_OUT}")
	endif()
	message("")
	message("")
	message("")
	if(__NOT_SUPERBUILD)
		message("    DECLARING  DEPENDENCIES  IN  PROJECT BUILD")
	else()
		message("    DECLARING  DEPENDENCIES  IN  SUPERBUILD")
	endif()
	message("")
endfunction()

function(__prepare_template_list)
	set(__TEMPLATE_FILENAME "${SUPERBUILD_ROOT}/build/templates.cmake")
	if(EXISTS "${__TEMPLATE_FILENAME}" AND FALSE)
		include("${__TEMPLATE_FILENAME}")
	else()
		file(GLOB_RECURSE __TARGETS_CMAKE_LIST CONFIGURE_DEPENDS "${SUPERBUILD_ROOT}/targets.cmake")
		file(GLOB_RECURSE __EXTERNAL_TARGETS_CMAKE_LIST CONFIGURE_DEPENDS "${SUPERBUILD_ROOT}/cmake/targets/*.cmake")
		set(__STR_OUT)
		set(__TEMPLATES__LIST)
		foreach(__FILE IN LISTS __TARGETS_CMAKE_LIST __EXTERNAL_TARGETS_CMAKE_LIST)
#			message(STATUS "__prepare_template_list(): Trying to read file ${__FILE}...")
			_read_targets_file("${__FILE}" __TARGETS_CMAKE_PREFIX __IS_TARGET_FIXED)
			foreach(__TARGET IN LISTS __TARGETS_CMAKE_PREFIX_ENUM_TEMPLATES)
#				string(REGEX REPLACE "^\\*" "" __TARGET "${__TEMPLATE}") #removes "*" in front of fixed targets
				string(REPLACE "::" "_" __TARGET_FIXED "${__TARGET}")
				string(REPLACE "-" "_" __TARGET_FIXED "${__TARGET_FIXED}")
				if("${__TARGET_FIXED}" IN_LIST __TEMPLATES)
					message(FATAL_ERROR "Duplicate template name detected. One instance declared in ${__TEMPLATES_${__TARGET_FIXED}} and the other in ${__FILE}")
				endif()
				list(APPEND __TEMPLATES__LIST "${__TARGET_FIXED}")
				set(__TEMPLATES_${__TARGET_FIXED} "${__FILE}" PARENT_SCOPE)
#				message(STATUS "__prepare_template_list(): Found ${__TARGET_FIXED}.")
				set(__STR_OUT "${__STR_OUT}\nset(__TEMPLATES_${__TARGET_FIXED} \"${__FILE}\" PARENT_SCOPE)")
			endforeach()
		endforeach()
		string(REPLACE ";" " " __TEMPLATES_SPACES "${__TEMPLATES__LIST}")
#		message(STATUS "__prepare_template_list(): __STR_OUT: ${__STR_OUT}")
		set(__STR_OUT "${__STR_OUT}\nset(__TEMPLATES__LIST ${__TEMPLATES_SPACES} PARENT_SCOPE)")
#		message(STATUS "__prepare_template_list(): __STR_OUT: ${__STR_OUT}")
		file(WRITE ${SUPERBUILD_ROOT}/build/templates.cmake "${__STR_OUT}")
	endif()
	message("")
	message("")
	message("")
	if(__NOT_SUPERBUILD)
		message("    DECLARING  DEPENDENCIES  IN  PROJECT BUILD")
	else()
		message("    DECLARING  DEPENDENCIES  IN  SUPERBUILD")
	endif()
	message("")
endfunction()

function(__find_targets_cmake_by_template_name __TEMPLATE_NAME __OUT_TARGETS_CMAKE_PATH __OUT_IS_TARGET_FIXED)
	set(__TEMPLATE_FILENAME "${SUPERBUILD_ROOT}/build/templates.cmake")
	if(EXISTS "${__TEMPLATE_FILENAME}")
		include("${__TEMPLATE_FILENAME}")
	else()
		message(FATAL_ERROR "Cannot find ${__TEMPLATE_FILENAME}")
	endif()
	string(REPLACE "::" "_" __TEMPLATE_NAME "${__TEMPLATE_NAME}")
	string(REPLACE "-" "_" __TEMPLATE_NAME "${__TEMPLATE_NAME}")
#	message(STATUS "__find_targets_cmake_by_template_name(): Looking up for __TEMPLATE_NAME: ${__TEMPLATE_NAME}")

	if(DEFINED __TEMPLATES_${__TEMPLATE_NAME})
		set(${__OUT_TARGETS_CMAKE_PATH} "${__TEMPLATES_${__TEMPLATE_NAME}}" PARENT_SCOPE)
		if("*${__TEMPLATE_NAME}" IN_LIST __TEMPLATES__LIST)
			set(${__OUT_IS_TARGET_FIXED} 1 PARENT_SCOPE)
		else()
			set(${__OUT_IS_TARGET_FIXED} 0 PARENT_SCOPE)
		endif()
	else()
		message(FATAL_ERROR "Cannot find ${__TEMPLATE_NAME} among known templates")
	endif()
endfunction()

__prepare_template_list()


