#The function that expects that the target described by the target properties already exists, and it simply brings it.
#It will never define a new target.
function(get_existing_target __TEMPLATE_NAME __OUT_INSTANCE_NAME)
	_get_target_behavior(__GET_TARGET_BEHAVIOR)
	set(__CALLING_FILE "${CMAKE_PARENT_LIST_FILE}")
	file(RELATIVE_PATH __CALLING_FILE ${SUPERBUILD_ROOT} ${__CALLING_FILE})
	
#	message(STATUS "Called get_target(${__TEMPLATE_NAME}) on phase ${__GET_TARGET_BEHAVIOR}")
	if("${__GET_TARGET_BEHAVIOR}" STREQUAL "INSIDE_GENERATE_TARGETS")
		message(FATAL_ERROR "Calling get_existing_target from inside generate_targets is disallowed. To call dependency use declare_dependencies() (in which you cannot define targets).")
	endif()
	if(NOT __TEMPLATE_NAME)
		message(FATAL_ERROR "get_error was called without any arguments")
	endif()
	_parse_TARGETS_PATH("${__TEMPLATE_NAME}" ${ARGN})
	
	_get_variables("${__TARGETS_CMAKE_PATH}" "${__CALLING_FILE}" "" __VARIABLE_DIC __PARAMETERS_DIC __TEMPLATES __EXTERNAL_PROJECT_INFO __IS_TARGET_FIXED __TEMPLATE_OPTIONS ${__ARGS})
	
	_make_instance_id(${__TEMPLATE_NAME} __VARIABLE_DIC "" __INSTANCE_ID __HASH_SOURCE) 
#	message(STATUS "get_target: __TEMPLATE_NAME ${__TEMPLATE_NAME} got __INSTANCE_ID: ${__INSTANCE_ID}")
	if("${__GET_TARGET_BEHAVIOR}" STREQUAL "GATHERING_DEPENDENCIES" OR "${__GET_TARGET_BEHAVIOR}" STREQUAL "OUTSIDE_SCOPE")
		#Add dependencies together with their arguments to the list. They will be instatiated later on, during generate_targets run
		_put_dependencies_into_stack("${__INSTANCE_ID}")
		_get_parent_dependency_from_stack(__PARENT_INSTANCE_ID)
		_store_instance_link_data(
			 ${__INSTANCE_ID}
			"${__PARENT_INSTANCE_ID}"
			__VARIABLE_DIC 
			__PARAMETERS_DIC
			 ${__TEMPLATE_NAME} 
			 ${__TARGETS_CMAKE_PATH} 
			 ${__IS_TARGET_FIXED}
			__EXTERNAL_PROJECT_INFO
			 0
			"${__TEMPLATE_OPTIONS}"
			 )
		_set_property_to_db(INSTANCEDB ${__INSTANCE_ID} I_HASH_SOURCE "${__HASH_SOURCE}")
	elseif("${__GET_TARGET_BEHAVIOR}" STREQUAL "DEFINING_TARGETS")
		_make_instance_name(${__INSTANCE_ID} __INSTANCE_NAME)
		if(NOT TARGET "${__INSTANCE_NAME}")
			get_filename_component(__TARGETS_CMAKE_DIR "${__TARGETS_CMAKE_PATH}" DIRECTORY)
	
			if(NOT "${__TEMPLATE_NAME}" IN_LIST __TEMPLATES)
				message(FATAL_ERROR "File ${__TARGETS_CMAKE_PATH} does not contain definition of template ${__TEMPLATE_NAME}")
			endif()
#			message(STATUS "get_target(): Instantiating dependencies for ${__TEMPLATE_NAME}...")
			_get_dependencies(${__TEMPLATE_NAME} "${__TARGETS_CMAKE_PATH}" __VARIABLE_DIC __DEP_INSTANCE_NAME_LIST)
			if("${__TEMPLATE_NAME}" STREQUAL "HELLO" AND NOT __DEP_INSTANCE_NAME_LIST)
				message(FATAL_ERROR "No dependencies for HELLO")
			endif()
#			message(STATUS "get_target(): Gathered the following dependencies for ${__TEMPLATE_NAME}: ${__DEP_INSTANCE_NAME_LIST}")
			_set_behavior_defining_targets() #So any call to the get_targets will raise an error. 
			_instantiate_target(${__TEMPLATE_NAME} ${__TARGETS_CMAKE_PATH} ${__INSTANCE_NAME} __VARIABLE_DIC "${__DEP_INSTANCE_NAME_LIST}")
		endif()
	else()
		message(FATAL_ERROR "Unknown global state __GET_TARGET_BEHAVIOR = \"${__GET_TARGET_BEHAVIOR}\"")
	endif()
	if(__OUT_INSTANCE_NAME)
		set(${__OUT_INSTANCE_NAME} "${__INSTANCE_NAME}" PARENT_SCOPE)
	endif()
endfunction()

function(build_target __TEMPLATE_NAME)
	get_target(${__TEMPLATE_NAME} __TMP_INSTANCE_NAME ${ARGN})
endfunction()

function(get_target __TEMPLATE_NAME __OUT_INSTANCE_NAME) 
	_get_target_behavior(__GET_TARGET_BEHAVIOR)
	set(__CALLING_FILE "${CMAKE_PARENT_LIST_FILE}")
	file(RELATIVE_PATH __CALLING_FILE ${SUPERBUILD_ROOT} ${__CALLING_FILE})
#	message(STATUS "Called get_target(${__TEMPLATE_NAME}) on phase ${__GET_TARGET_BEHAVIOR}")
	if("${__GET_TARGET_BEHAVIOR}" STREQUAL "INSIDE_GENERATE_TARGETS")
		message(FATAL_ERROR "Calling get_target from inside generate_targets is disallowed. To call dependency use declare_dependencies() (in which you cannot define targets).")
	endif()
	if(NOT __TEMPLATE_NAME)
		message(FATAL_ERROR "get_error was called without any arguments")
	endif()
	_parse_TARGETS_PATH("${__TEMPLATE_NAME}" ${ARGN})
#	message(STATUS "get_target(): ARGN: ${ARGN}")
	_get_variables("${__TARGETS_CMAKE_PATH}" "${__CALLING_FILE}" "" 1 __VARIABLE_DIC __PARAMETERS_DIC __TEMPLATES __EXTERNAL_PROJECT_INFO __IS_TARGET_FIXED __TEMPLATE_OPTIONS ${__ARGS})
#	if(__TEMPLATE_OPTIONS)
#		message(STATUS "get_target(): __TEMPLATE_OPTIONS: ${__TEMPLATE_OPTIONS}")
#	endif()
	if("${__VARIABLE_DIC_VERSION}" STREQUAL "KUC")
		message(FATAL_ERROR "__VARIABLE_DIC_VERSION: ${__VARIABLE_DIC_VERSION}")
	endif()
	_make_instance_id(${__TEMPLATE_NAME} __VARIABLE_DIC "" __INSTANCE_ID __HASH_SOURCE)
#	message(STATUS "get_target: __TEMPLATE_NAME ${__TEMPLATE_NAME} got __INSTANCE_ID: ${__INSTANCE_ID}")
	if("${__GET_TARGET_BEHAVIOR}" STREQUAL "GATHERING_DEPENDENCIES" OR "${__GET_TARGET_BEHAVIOR}" STREQUAL "OUTSIDE_SCOPE")
		#Add dependencies together with their arguments to the list. They will be instatiated later on, during generate_targets run
		_discover_dependencies(${__INSTANCE_ID} ${__TEMPLATE_NAME} "${__TARGETS_CMAKE_PATH}" __VARIABLE_DIC __PARAMETERS_DIC __EXTERNAL_PROJECT_INFO ${__IS_TARGET_FIXED} "${__TEMPLATE_OPTIONS}" "${__HASH_SOURCE}")
	elseif("${__GET_TARGET_BEHAVIOR}" STREQUAL "DEFINING_TARGETS")
		_make_instance_name(${__INSTANCE_ID} __INSTANCE_NAME)
		if(NOT TARGET "${__INSTANCE_NAME}")
			get_filename_component(__TARGETS_CMAKE_DIR "${__TARGETS_CMAKE_PATH}" DIRECTORY)
	
			if(NOT "${__TEMPLATE_NAME}" IN_LIST __TEMPLATES)
				message(FATAL_ERROR "File ${__TARGETS_CMAKE_PATH} does not contain definition of template ${__TEMPLATE_NAME}")
			endif()
#			message(STATUS "get_target(): Instantiating dependencies for ${__TEMPLATE_NAME}...")
			_get_dependencies(${__TEMPLATE_NAME} "${__TARGETS_CMAKE_PATH}" __VARIABLE_DIC __DEP_INSTANCE_NAME_LIST)
			if("${__TEMPLATE_NAME}" STREQUAL "HELLO" AND NOT __DEP_INSTANCE_NAME_LIST)
				message(FATAL_ERROR "No dependencies for HELLO")
			endif()
#			message(STATUS "get_target(): Gathered the following dependencies for ${__TEMPLATE_NAME}: ${__DEP_INSTANCE_NAME_LIST}")
			_set_behavior_defining_targets() #So any call to the get_targets will raise an error. 
			_instantiate_target(${__TEMPLATE_NAME} ${__TARGETS_CMAKE_PATH} ${__INSTANCE_NAME} __VARIABLE_DIC "${__DEP_INSTANCE_NAME_LIST}")
		endif()
	else()
		message(FATAL_ERROR "Unknown global state __GET_TARGET_BEHAVIOR = \"${__GET_TARGET_BEHAVIOR}\"")
	endif()
	if(__OUT_INSTANCE_NAME)
		set(${__OUT_INSTANCE_NAME} "${__INSTANCE_NAME}" PARENT_SCOPE)
	endif()
endfunction()

#Calls targets.cmake:generate_targets() to create the declared target during the project phase run of the CMake. 
#Does nothing on the SUPERBUILD phase, as the internal project dependencies are of no concern then.
function(_get_target_internal __INSTANCE_ID __OUT_FUNCTION_EXISTS)
#	message(STATUS "Inside _get_target_internal trying to instantiate ${__INSTANCE_NAME}")
	if(NOT __NOT_SUPERBUILD)
		return()
	endif()
	_retrieve_instance_data(${__INSTANCE_ID} I_TEMPLATE_NAME __TEMPLATE_NAME)
	_make_instance_name(${__INSTANCE_ID} __INSTANCE_NAME)
	_retrieve_instance_data(${__INSTANCE_ID} PATH __TARGETS_CMAKE_PATH)

	_retrieve_instance_args(${__INSTANCE_ID} I_FEATURES __ARGS)
	set(__ARGS__LIST_FEATURES "${__ARGS__LIST}")
	_retrieve_instance_args(${__INSTANCE_ID} MODIFIERS __ARGS)
	set(__ARGS__LIST_MODIFIERS "${__ARGS__LIST}")
	list(APPEND __ARGS__LIST ${__ARGS__LIST_FEATURES})
	
	_retrieve_instance_data(${__INSTANCE_ID} DEP_INSTANCES __DEP_ID_LIST)
	
	if(NOT __TARGETS_CMAKE_PATH)
		message(FATAL_ERROR "Internal error: Empty __TARGETS_CMAKE_PATH")
	endif()
	
	#We need to populate all dependencies, so their names can be used in the targets.cmake
	set(__DEP_EXPVAR_LIST)
	if(__DEP_ID_LIST)
		foreach(__DEP_ID IN LISTS __DEP_ID_LIST)
			_make_instance_name(${__DEP_ID} __DEP_NAME)
			_retrieve_instance_data(${__DEP_ID} I_TEMPLATE_NAME __DEP_TEMPLATE_NAME)
			string(REPLACE "::" "_" __DEP_TEMPLATE_NAME "${__DEP_TEMPLATE_NAME}")
		
			list(APPEND ${__DEP_TEMPLATE_NAME}_TARGET_NAME "${__DEP_NAME}")
			_retrieve_instance_data(${__DEP_ID} EXPORTED_VARS __EXPORTED_VARS)
			_retrieve_instance_data(${__DEP_ID} SOURCE_DIR __DEP_SOURCE_DIR)
			if(__DEP_SOURCE_DIR)
				list(APPEND __EXPORTED_VARS ${__DEP_TEMPLATE_NAME}_SOURCE_DIR)
				set(${__DEP_TEMPLATE_NAME}_SOURCE_DIR "${__DEP_SOURCE_DIR}")
#				message(STATUS "_get_target_internal(): ${__DEP_TEMPLATE_NAME}_SOURCE_DIR: ${__DEP_SOURCE_DIR}")
			endif()
			_retrieve_instance_data(${__DEP_ID} INSTALL_DIR __DEP_INSTALL_DIR)
			if(__DEP_INSTALL_DIR)
				list(APPEND __EXPORTED_VARS ${__DEP_TEMPLATE_NAME}_INSTALL_DIR)
				set(${__DEP_TEMPLATE_NAME}_INSTALL_DIR "${__DEP_INSTALL_DIR}")
#				message(STATUS "_get_target_internal() ${__DEP_TEMPLATE_NAME}_INSTALL_DIR: ${__DEP_INSTALL_DIR}")
			endif()
			if(__EXPORTED_VARS)
#				message(STATUS "_get_target_internal() __EXPORTED_VARS: ${__EXPORTED_VARS}: ${Serialbox_SerialboxCStatic_INSTALL_DIR}")
				_retrieve_instance_args(${__DEP_ID} LINKPARS  __DEPVARS)
				_retrieve_instance_args(${__DEP_ID} I_FEATURES  __DEPVARS)
				_retrieve_instance_args(${__DEP_ID} MODIFIERS __DEPVARS)
				foreach(__EXPVAR IN LISTS __EXPORTED_VARS)
					if("${__EXPVAR}" IN_LIST __ARGS__LIST)
						_get_nice_name(${__DEP_ID} __NICE_NAME_DEP)
						_get_nice_name(${__INSTANCE_ID} __NICE_NAME_WE)
						message(WARNING "Exported variable ${__EXPVAR} from ${__NICE_NAME_DEP} will not be available in ${__NICE_NAME_WE} because it is shadowed by the variable of the same name declared in it.")
					elseif("${__EXPVAR}" IN_LIST __DEP_EXPVAR_LIST AND NOT "${__EXPVAR}" STREQUAL "${__DEPVARS_${__EXPVAR}}")
						_get_nice_name(${__DEP_ID} __NICE_NAME_DEP)
						_get_nice_name(${__INSTANCE_ID} __NICE_NAME_WE)
						_retrieve_instance_args(${__DEP_ID} PATH __DEPPATH)
						file(RELATIVE_PATH __DEPPATH ${SUPERBUILD_ROOT} "${__DEPPATH}")

						message(FATAL_ERROR "Variable ${__EXPVAR}= \"${__DEPVARS_${__EXPVAR}}\" exported from ${__NICE_NAME_DEP} has already been imported from other dependency, but with different value: \"${__EXPVAR}\". Remove this variable from the list of exported variables in ${__DEPPATH} or make sure they all have the same value.")
					else()
						if(NOT "${__EXPVAR}" STREQUAL "${__DEP_TEMPLATE_NAME}_SOURCE_DIR" AND NOT "${__EXPVAR}" STREQUAL "${__DEP_TEMPLATE_NAME}_INSTALL_DIR")
							set(${__EXPVAR} "${__DEPVARS_${__EXPVAR}}")
						endif()
						list(APPEND __DEP_EXPVAR_LIST ${__EXPVAR})
					endif()
#					message(STATUS "_get_target_internal()0 __DEP_ID: ${__DEP_ID} __EXPVAR: ${__EXPVAR}:${${__EXPVAR}} Serialbox_SerialboxCStatic_INSTALL_DIR: ${Serialbox_SerialboxCStatic_INSTALL_DIR}")

				endforeach()
			endif()
		endforeach()
	endif()
	
#	message(STATUS "_get_target_internal()1 Serialbox_SerialboxCStatic_INSTALL_DIR: ${Serialbox_SerialboxCStatic_INSTALL_DIR}")
	set(TARGET_NAME ${__INSTANCE_NAME})
	set(${__TEMPLATE_NAME}_TARGET_NAME ${__INSTANCE_NAME})
	_instantiate_variables(__ARGS "${__ARGS__LIST}")
#	message(STATUS "_get_target_internal()2 Serialbox_SerialboxCStatic_INSTALL_DIR: ${Serialbox_SerialboxCStatic_INSTALL_DIR}")
	get_filename_component(__TEMPLATE_DIR "${__TARGETS_CMAKE_PATH}" DIRECTORY)
	_read_functions_from_targets_file("${__TARGETS_CMAKE_PATH}")
#	message(STATUS "_get_target_internal()3 Serialbox_SerialboxCStatic_INSTALL_DIR: ${Serialbox_SerialboxCStatic_INSTALL_DIR}")
	
	set(CMAKE_CURRENT_SOURCE_DIR "${__TEMPLATE_DIR}")
	
#	message(FATAL_ERROR "Going to call generate targets for ${__TEMPLATE_NAME} from ${__TARGETS_CMAKE_PATH} with instance name set as «${__INSTANCE_NAME}» ")
	unset(__NO_OP)

	generate_targets(${__TEMPLATE_NAME})
	_retrieve_instance_data(${__INSTANCE_ID} NO_TARGETS __NO_TARGETS )
	_retrieve_instance_data(${__INSTANCE_ID} TARGETS_REQUIRED __TARGETS_REQUIRED )
	if(__NO_OP)
		_get_target_behavior(__TARGET_BEHAVIOR)
		if("${__TARGET_BEHAVIOR}" STREQUAL "OUTSIDE_SCOPE")
			message(FATAL_ERROR "File ${CMAKE_CURRENT_SOURCE_DIR}/targets.cmake did not define generate_targets() function.")
		endif()
		if(__TARGETS_REQUIRED)
			message(FATAL_ERROR "File ${CMAKE_CURRENT_SOURCE_DIR}/targets.cmake did not define generate_targets() function. If you cannot produce targets, please add NO_TARGETS option to TEMPLATE_OPTIONS variable defined in this file.")
		endif()
		set(${__OUT_FUNCTION_EXISTS} 0 PARENT_SCOPE)
	else()
		if(__NO_TARGETS)
			message(FATAL_ERRLR "File ${CMAKE_CURRENT_SOURCE_DIR}/targets.cmake defined generate_targets() function while also declared NO_TARGETS option.")
		endif()
		if(__TARGETS_REQUIRED AND NOT TARGET "${${__TEMPLATE_NAME}_TARGET_NAME}")
			message(FATAL_ERROR "Called ${__TEMPLATE_DIR}/targets.cmake:generate_targets(${__TEMPLATE_NAME}) which did not produce the target with name TARGET_NAME = \"${TARGET_NAME}\"" )
		endif()
		set(${__OUT_FUNCTION_EXISTS} 1 PARENT_SCOPE)
	endif()
endfunction()

