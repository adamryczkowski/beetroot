# _get_variables(<path to targets.cmake> <out_arguments_prefix> <out_template_names> <out_DEFINE_EXTERNAL_PROJECT> <Args...>)
#
# Parses targets.cmake and gets the actual value of the variables based on the 
# 1. defaults declared in targets.cmake,
# 2. overriden by pre-existing CMake variables which names matches the declared parameters in the targets.cmake
# 3. overriden by named arguments passed in Args... .
# The values are checked for validity and stored in the standard format in prefix out_arguments_prefix. 
# Moreover it saves template names declared in the targets.cmake (in ${out_template_names}) and information about external project in ${out_external}.
#
# The algorithm allows for default values for parameters to be dependent on other variables, which allows to encode parameter transformation logic, because the
# values for the variables will be taken _after_ injecting the cached variables and - which is non trivial - the arguments Args... (which override everything).
#
# Moreover, the mentioned algorithm is run several times, as long as the names of the variables stabilise. That means, that variable defined as 
#
# set(LINK_PARAMETERS 
#	NEVER_ENDING_INTEGER	SCALAR	INTEGER "${NEVER_ENDING_INTEGET}+1")
#
# Will never parse, because on each run of the algorithm the value for NEVER_ENDING_INTEGET will be different. 
#
# But this is usefull for e.g.
#
# if("${MY_OTHER_ARG}" STREQUAL "1" )
#	set(TMP "SINGULAR")
# else()
#	set(TMP "PLURAL")
# endif()
#
# set(LINK_PARAMETERS 
#	MY_OTHER_ARG	SCALAR	INTEGER 1
#	ARG	SCALAR	CHOICE(SINGULAR;PLURAL) ${TMP}
# )
function(_get_variables __TARGETS_CMAKE_PATH __CALLING_FILE __ARGS_IN __OUT_VARIABLE_DIC __OUT_PARAMETERS_DIC __OUT_TEMPLATE_NAMES __OUT_EXTERNAL_PROJECT_INFO __OUT_IS_TARGET_FIXED __OUT_GLOBAL_OPTIONS)
	set(__ARGUMENT_HASH)
	set(__ITERATION_COUNT 0)

	set(__ARGUMENT_HASH_OLD "")

	set(__DEBUG_VAR_NAME BCTYPE)
#	message(WARNING "_get_variables(): __ARGS_IN: ${__ARGS_IN} __TARGETS_CMAKE_PATH: ${__TARGETS_CMAKE_PATH}")
	foreach(__ITERATION RANGE 10)
#		if(__ARGS_${__DEBUG_VAR_NAME})
#			message(STATUS "_get_variables(): __ITERATION: ${__ITERATION}, phase 1, __ARGS_${__DEBUG_VAR_NAME}: ${__ARGS_${__DEBUG_VAR_NAME}}")
#		endif()
		if(${__ITERATION} EQUAL 0)
			_read_parameters("${__TARGETS_CMAKE_PATH}" "${__ARGS_IN}" __PARS __ARGS __IN_TEMPLATE_NAMES __IN_EXTERNAL_PROJECT_INFO __IN_IS_TARGET_FIXED __GLOBAL_OPTIONS)
		else()
			_read_parameters("${__TARGETS_CMAKE_PATH}" __ARGS __PARS __ARGS __IN_TEMPLATE_NAMES __IN_EXTERNAL_PROJECT_INFO __IN_IS_TARGET_FIXED __GLOBAL_OPTIONS)
		endif()
#		message(STATUS "_get_variables(): __ARGS__SRC_BCTYPE: ${__ARGS__SRC_BCTYPE}")

#		message(STATUS "_get_variables(): __PARS_${__DEBUG_VAR_NAME}__TYPE: ${__PARS_${__DEBUG_VAR_NAME}__TYPE}")
#		if(__ARGS_${__DEBUG_VAR_NAME})
#			message(STATUS "_get_variables(): __ITERATION: ${__ITERATION}, phase 2, __ARGS_${__DEBUG_VAR_NAME}: ${__ARGS_${__DEBUG_VAR_NAME}}")
#		endif()
		if(NOT __PARS__LIST)
			break() #no variables
		endif()
		_read_variables_from_cache(__PARS __ARGS "" cache __ARGS)
#		message(STATUS "_get_variables(): __ARGS__SRC_BCTYPE: ${__ARGS__SRC_BCTYPE}")
#		if(__ARGS_${__DEBUG_VAR_NAME})
#			message(STATUS "_get_variables(): __ITERATION: ${__ITERATION}, phase 3, __ARGS_${__DEBUG_VAR_NAME}: ${__ARGS_${__DEBUG_VAR_NAME}} ARGN: ${ARGN}")
#		endif()
#		message(STATUS "_get_variables(): ARGN: ${ARGN}")

		_read_variables_from_args(__PARS __ARGS __ARGS ${ARGN})
#		if(__ARGS_${__DEBUG_VAR_NAME})
#			message(STATUS "_get_variables(): __ITERATION: ${__ITERATION}, phase 4, __ARGS_${__DEBUG_VAR_NAME}: ${__ARGS_${__DEBUG_VAR_NAME}}")
#		endif()
#		message(STATUS "_get_variables(): __ARGS__SRC_BCTYPE: ${__ARGS__SRC_BCTYPE}")
		_calculate_hash(__ARGS "${__ARGS__LIST}" "_getvars_" __ARGUMENT_HASH_NEW __HASH_SOURCE)
		
#		message(STATUS "_get_variables(): __ARGUMENT_HASH_OLD: ${__ARGUMENT_HASH_OLD}, __ARGUMENT_HASH_NEW: ${__ARGUMENT_HASH_NEW}, __IN_EXTERNAL_PROJECT_INFO: ${__IN_EXTERNAL_PROJECT_INFO}")
		if("${__ARGUMENT_HASH_NEW}" STREQUAL "${__ARGUMENT_HASH_OLD}")
			break()
		endif()
		set(__ARGUMENT_HASH_OLD "${__ARGUMENT_HASH_NEW}")
	endforeach()
#	if("${__TARGETS_CMAKE_PATH}" MATCHES "/serialbox.cmake")
#		message(WARNING "_get_variables(): __TARGETS_CMAKE_PATH: ${__TARGETS_CMAKE_PATH} __IN_EXTERNAL_PROJECT_INFO: ${__IN_EXTERNAL_PROJECT_INFO} __IN_TEMPLATE_NAMES: ${__IN_TEMPLATE_NAMES} __OUT_EXTERNAL_PROJECT_INFO: ${__OUT_EXTERNAL_PROJECT_INFO}")
#	else()
#		message(STATUS "_get_variables(): __TARGETS_CMAKE_PATH: ${__TARGETS_CMAKE_PATH} __IN_EXTERNAL_PROJECT_INFO: ${__IN_EXTERNAL_PROJECT_INFO} __IN_TEMPLATE_NAMES: ${__IN_TEMPLATE_NAMES}")
#	endif()
	
	foreach(__VAR_NAME IN LISTS __PARS__LIST)
		if("${__ARGS__SRC_${__VAR_NAME}}" STREQUAL "default")
			set(__SRC "as default parameter in ${__TARGETS_CMAKE_PATH}")
		elseif("${__ARGS__SRC_${__VAR_NAME}}" STREQUAL "cache")
			set(__SRC "as already set variable, perhaps in the calling CMakeLists.txt")
		elseif("${__ARGS__SRC_${__VAR_NAME}}" STREQUAL "args")
			set(__SRC "as explicitely set function named argument in the ${__CALLING_FILE}")
		else()
			message(FATAL_ERROR "Internal beetroot error: Unknown source of variable ${__VAR_NAME}: __ARGS__SRC_${__VAR_NAME}: ${__ARGS__SRC_${__VAR_NAME}}")
		endif()
		if(${__VAR_NAME} IN_LIST __PARS__LIST_FEATURES)
			set(__BOOL_FEATURES 1)
		else()
			set(__BOOL_FEATURES 0)
		endif()
		_verify_parameter("${__VAR_NAME}" "${__SRC}" "${__PARS_${__VAR_NAME}__CONTAINER}" "${__PARS_${__VAR_NAME}__TYPE}" "${__ARGS_${__VAR_NAME}}" ${__BOOL_FEATURES})
	endforeach()
	
	if(NOT "${__ARGUMENT_HASH_NEW}" STREQUAL "${__ARGUMENT_HASH_OLD}")
		message(FATAL_ERROR "Could not converge the values of arguments after ${__ITERATION} iterations")
	endif()
#	if(__ARGS_${__DEBUG_VAR_NAME})
#		message(WARNING "_get_variables(): __ITERATION: ${__ITERATION}, phase 4, __ARGS_${__DEBUG_VAR_NAME}: ${__ARGS_${__DEBUG_VAR_NAME}}")
#	endif()
	
	_pass_arguments_higher(__ARGS ${__OUT_VARIABLE_DIC})
	_pass_parameters_higher(__PARS ${__OUT_PARAMETERS_DIC})
	set(${__OUT_TEMPLATE_NAMES} "${__IN_TEMPLATE_NAMES}" PARENT_SCOPE)
	set(${__OUT_EXTERNAL_PROJECT_INFO} "${__IN_EXTERNAL_PROJECT_INFO}" PARENT_SCOPE)
	set(${__OUT_IS_TARGET_FIXED} "${__IN_IS_TARGET_FIXED}" PARENT_SCOPE)
	set(${__OUT_GLOBAL_OPTIONS} "${__GLOBAL_OPTIONS}" PARENT_SCOPE)
	
endfunction()

macro(_pass_arguments_higher __IN_PREFIX __OUT_PREFIX)
#	message(FATAL_ERROR "${__IN_PREFIX}__LIST: ${${__IN_PREFIX}__LIST}")
	foreach(__VAR IN LISTS ${__IN_PREFIX}__LIST)
#		message(FATAL_ERROR "set(${__OUT_PREFIX}_${__VAR} \"${${__IN_PREFIX}_${__VAR}}\" PARENT_SCOPE)")
		set(${__OUT_PREFIX}_${__VAR} "${${__IN_PREFIX}_${__VAR}}" PARENT_SCOPE)
		if(NOT "${${__IN_PREFIX}__SRC_${__VAR}}" STREQUAL "")
			set(${__OUT_PREFIX}__SRC_${__VAR} "${${__IN_PREFIX}__SRC_${__VAR}}" PARENT_SCOPE)
		endif()
	endforeach()
	set(${__OUT_PREFIX}__LIST "${${__IN_PREFIX}__LIST}" PARENT_SCOPE)
#	set(${__OUT_PREFIX}__LIST_MODIFIERS "${${__IN_PREFIX}__LIST_MODIFIERS}" PARENT_SCOPE)
endmacro()

macro(_pass_parameters_higher __IN_PREFIX __OUT_PREFIX)
	foreach(__VAR IN LISTS ${__IN_PREFIX}__LIST)
		set(${__OUT_PREFIX}_${__VAR}__CONTAINER "${${__IN_PREFIX}_${__VAR}__CONTAINER}" PARENT_SCOPE)
		set(${__OUT_PREFIX}_${__VAR}__TYPE "${${__IN_PREFIX}_${__VAR}__TYPE}" PARENT_SCOPE)
	endforeach()
	set(${__OUT_PREFIX}__LIST "${${__IN_PREFIX}__LIST}" PARENT_SCOPE)
	set(${__OUT_PREFIX}__LIST_MODIFIERS "${${__IN_PREFIX}__LIST_MODIFIERS}" PARENT_SCOPE)
	set(${__OUT_PREFIX}__LIST_FEATURES "${${__IN_PREFIX}__LIST_FEATURES}" PARENT_SCOPE)
	set(${__OUT_PREFIX}__LIST_LINKPARS "${${__IN_PREFIX}__LIST_LINKPARS}" PARENT_SCOPE)
endmacro()

macro(_parse_parameters __DEFINITIONS __OUT_ARGS __OUT_PARS __TARGETS_CMAKE_PATH __BOOL_FEATURES)
#	set(__DEFINITIONS ${__DEFINITIONS})
	list(LENGTH ${__DEFINITIONS} __TMP)
	
#	message(STATUS "_parse_parameters(), __TMP: ${__TMP}, __DEFINITIONS=${${__DEFINITIONS}}")
	math(EXPR __PARS_LENGTH "${__TMP} / 4 - 1")
	math(EXPR __PARS_CHECK "${__TMP} % 4")
	if(NOT "${__PARS_CHECK}" STREQUAL "0")
		message(FATAL_ERROR "Wrong number of elements in the PARAMETERS/FEATURES variable defined in ${__TARGETS_CMAKE_PATH}. Expected number of elements divisible by 4, but got ${__TMP} elements: ${${__DEFINITIONS}}")
	endif()
#	message(STATUS "_parse_parameters(), __PARS_LENGTH=${__PARS_LENGTH}")
	if(NOT "${__TMP}" STREQUAL 0)
		set(__LIST)
		foreach(__VAR_NR RANGE "${__PARS_LENGTH}")
			math(EXPR __TMP "${__VAR_NR}*4")
			list(GET ${__DEFINITIONS} ${__TMP} __VAR_NAME )
			if( "${__VAR_NAME}" MATCHES "^_.*$")
				message(FATAL_ERROR "Cannot declare variables that start with underscore (like \"${__VARNAME}\"). Error encountered in ${__TARGETS_CMAKE_PATH}.")
			endif()
			if(NOT "${__VAR_NAME}" MATCHES "^[A-Za-z][A-Za-z0-9_]*$")
				message(FATAL_ERROR "Variables must start with the letter and consit only from letters, digits and underscores, not like \"${__VARNAME}\" encounterd in ${__TARGETS_CMAKE_PATH}.")
			endif()
			if("${__VAR_NAME}" IN_LIST ${__OUT_ARGS}__LIST)
				message(FATAL_ERROR "Multiple definitions of the same variable/modifier (here: \"${__VARNAME}\") are not allowed. Modifiers and variables share the same namespace. Error encountered in ${__TARGETS_CMAKE_PATH}.")
			endif()
			math(EXPR __TMP "${__VAR_NR}*4 + 1")
			list(GET ${__DEFINITIONS} ${__TMP} ${__OUT_PARS}_${__VAR_NAME}__CONTAINER)
			math(EXPR __TMP "${__VAR_NR}*4 + 2")
			list(GET ${__DEFINITIONS} ${__TMP} ${__OUT_PARS}_${__VAR_NAME}__TYPE)
			math(EXPR __TMP "${__VAR_NR}*4 + 3")
			list(GET ${__DEFINITIONS} ${__TMP} __VAR_DEFAULT)
			if("${${__OUT_PARAMETERS_PREFIX}_${__VAR_NAME}__CONTAINER}" STREQUAL "VECTOR")
				string(REPLACE ":" ";" __VAR_DEFAULT "${__VAR_DEFAULT}")
			endif()
#			_verify_parameter("${__VAR_NAME}" "as default parameter in ${__TARGETS_CMAKE_PATH}" "${${__OUT_PARS}_${__VAR_NAME}__CONTAINER}" "${${__OUT_PARS}_${__VAR_NAME}__TYPE}" "${__VAR_DEFAULT}" ${__BOOL_FEATURES})
			set(${__OUT_ARGS}_${__VAR_NAME} "${__VAR_DEFAULT}")
			set(${__OUT_ARGS}__SRC_${__VAR_NAME} default)
			list(APPEND ${__OUT_ARGS}__LIST "${__VAR_NAME}")
			list(APPEND ${__OUT_PARS}__LIST "${__VAR_NAME}")
#			message(STATUS "_parse_parameters(): Found variable ${__VAR_NAME} with container ${__OUT_PARS}_${__VAR_NAME}__CONTAINER: ${${__OUT_PARS}_${__VAR_NAME}__CONTAINER}")
		endforeach()
	endif()
endmacro()

# Reads, parses and checks parameter definition from targets.cmake.
# Also initializes argument list with the default value of each parameter.
function(_read_parameters __TARGETS_CMAKE_PATH __EXISTING_ARGS __OUT_PARAMETERS_PREFIX __OUT_ARGUMENTS_PREFIX __OUT_TEMPLATE_NAMES __OUT_EXTERNAL_PROJECT_INFO __OUT_IS_TARGET_FIXED __OUT_GLOBAL_OPTIONS)
	if(__EXISTING_ARGS)
		_instantiate_variables(${__EXISTING_ARGS} "${${__EXISTING_ARGS}__LIST}" )
	endif()
	_read_targets_file("${__TARGETS_CMAKE_PATH}" __READ_PREFIX __IS_TARGET_FIXED)
	

	set(${__OUT_ARGUMENTS_PREFIX}__LIST)
	set(${__OUT_PARAMETERS_PREFIX}__LIST_MODIFIERS)
	set(${__OUT_PARAMETERS_PREFIX}__LIST_FEATURES)
	set(${__OUT_PARAMETERS_PREFIX}__LIST_LINKPARS)

	set(${__OUT_PARAMETERS_PREFIX}__LIST)
	
	_parse_parameters(__READ_PREFIX_TARGET_PARAMETERS ${__OUT_ARGUMENTS_PREFIX} ${__OUT_PARAMETERS_PREFIX} "${__TARGETS_CMAKE_PATH}" 0)
#	message(STATUS "_read_parameters(): __READ_PREFIX_TARGET_PARAMETERS: ${__READ_PREFIX_TARGET_PARAMETERS}")
#	message(STATUS "_read_parameters(): ${__OUT_PARAMETERS_PREFIX}__LIST: ${${__OUT_PARAMETERS_PREFIX}__LIST}")
	set(${__OUT_PARAMETERS_PREFIX}__LIST_MODIFIERS "${${__OUT_PARAMETERS_PREFIX}__LIST}")


	set(${__OUT_PARAMETERS_PREFIX}__LIST)
	_parse_parameters(__READ_PREFIX_TARGET_FEATURES ${__OUT_ARGUMENTS_PREFIX} ${__OUT_PARAMETERS_PREFIX} "${__TARGETS_CMAKE_PATH}" 1)
	set(${__OUT_PARAMETERS_PREFIX}__LIST_FEATURES "${${__OUT_PARAMETERS_PREFIX}__LIST}")
	list_intersect(__INTERSECT ${__OUT_PARAMETERS_PREFIX}__LIST_MODIFIERS ${__OUT_PARAMETERS_PREFIX}__LIST_FEATURES)
	if(__INTERSECT)
		message(FATAL_ERROR "The parameters ${__INTERSECT} are defined both in TARGET_PARAMETERS and TARGET_FEATURES. Parameters in TARGET_FEATURES, TARGET_PARAMETERS and LINK_PARAMETERS share the same namespace and it is illegal to re-define already defined parameter.")
	endif()

	set(${__OUT_PARAMETERS_PREFIX}__LIST)
	_parse_parameters(__READ_PREFIX_LINK_PARAMETERS ${__OUT_ARGUMENTS_PREFIX} ${__OUT_PARAMETERS_PREFIX} "${__TARGETS_CMAKE_PATH}" 0)
	set(${__OUT_PARAMETERS_PREFIX}__LIST_LINKPARS "${${__OUT_PARAMETERS_PREFIX}__LIST}")
	set(__LIST ${${__OUT_PARAMETERS_PREFIX}__LIST_MODIFIERS} ${${__OUT_PARAMETERS_PREFIX}__LIST_FEATURES})
	list_intersect(__INTERSECT __LIST ${__OUT_PARAMETERS_PREFIX}__LIST_LINKPARS)
	if(__INTERSECT)
		message(FATAL_ERROR "The parameters ${__INTERSECT} are defined both in LINK_PARAMETERS and one of TARGET_PARAMETERS and TARGET_FEATURES. Parameters in TARGET_FEATURES, TARGET_PARAMETERS and LINK_PARAMETERS share the same namespace and it is illegal to re-define already defined parameter.")
	endif()
	
	set(${__OUT_PARAMETERS_PREFIX}__LIST ${${__OUT_PARAMETERS_PREFIX}__LIST_MODIFIERS} ${${__OUT_PARAMETERS_PREFIX}__LIST_FEATURES} ${${__OUT_PARAMETERS_PREFIX}__LIST_LINKPARS})
	
	_pass_arguments_higher(${__OUT_ARGUMENTS_PREFIX} ${__OUT_ARGUMENTS_PREFIX})
	_pass_parameters_higher(${__OUT_PARAMETERS_PREFIX} ${__OUT_PARAMETERS_PREFIX})
	
	
	set(${__OUT_TEMPLATE_NAMES} "${__READ_PREFIX_ENUM_TEMPLATES}" PARENT_SCOPE)
	set(${__OUT_EXTERNAL_PROJECT_INFO} "${__READ_PREFIX_DEFINE_EXTERNAL_PROJECT}" PARENT_SCOPE)
	set(${__OUT_IS_TARGET_FIXED} "${__IS_TARGET_FIXED}" PARENT_SCOPE)
	set(${__OUT_GLOBAL_OPTIONS} "${__READ_PREFIX_TEMPLATE_OPTIONS}" PARENT_SCOPE)
endfunction()


# Calculates hash of the ARGS prefix. 
# The hash is independent from the order in which ARGS is layed out, because it first sorts it.
# It also appends __EXTRA_STRING to the hashed string, so it can encode some extra information as well (e.g. template name)
function(_calculate_hash __PREFIX __VAR_LIST __EXTRA_STRING __OUT_HASH __OUT_HASH_SOURCE)
	set(__STRING_SO_FAR "${__EXTRA_STRING}")
#	message(STATUS "_calculate_hash(): __EXTRA_STRING=${__EXTRA_STRING} __LIST_MODIFIERS=${${__PREFIX}__LIST_MODIFIERS}")
	if(__VAR_LIST)
		list(SORT __VAR_LIST COMPARE STRING CASE INSENSITIVE ORDER ASCENDING)
		foreach(__ARG IN LISTS __VAR_LIST)
			set(__STRING_SO_FAR "${__STRING_SO_FAR};${${__PREFIX}_${__ARG}}")
#			message(STATUS "_calculate_hash(): __ARG: ${__ARG}, ${__PREFIX}_${__ARG}: \"${${__PREFIX}_${__ARG}}\"")
		endforeach()
		set(${__OUT_HASH_SOURCE} "${__OUT_HASH_SOURCE}" PARENT_SCOPE)
		string(MD5 __HASH "${__STRING_SO_FAR}")
		set(${__OUT_HASH} "${__HASH}" PARENT_SCOPE)
#		message(STATUS "_calculate_hash(): Calculated hash: ${__HASH} from variables ${__VAR_LIST} based on string \"${__STRING_SO_FAR}\"")
	else()
		set(${__OUT_HASH} "${__EXTRA_STRING}" PARENT_SCOPE)
		set(${__OUT_HASH_SOURCE} "${__EXTRA_STRING}" PARENT_SCOPE)
	endif()
endfunction()


# _read_variables_from_cache(__PARS __ARGS __VALUES __OUT_ARGS)
#
# Iterates over all variables in __PARS, and combines the values taken from __ARGS with overrides taken as the same name, but with optional prefix __VALUES.
#
# It also validates the variable, if it is taken from __VALUES and __PARS is not equal ""
function(_read_variables_from_cache __PARS __ARGS __VALUES __SOURCE __OUT_ARGS)
	foreach(__VAR IN LISTS ${__ARGS}__LIST)
		if(NOT "${${__VAR}}" STREQUAL "")
			set(__EXT_VARNAME ${__VAR})
		else()
			set(__EXT_VARNAME ${__VALUES}_${__VAR})
		endif()
		if(DEFINED ${__EXT_VARNAME})
			if(__PARS)
				if("${__VAR}" IN_LIST ${__PARS}__LIST_FEATURES)
					set(__FEATURE 1)
				else()
					set(__FEATURE 0)
				endif()
#				_verify_parameter("${__VAR}" "as defined value ${__EXT_VARNAME}" "${${__PARS}_${__VAR}__CONTAINER}" "${${__PARS}_${__VAR}__TYPE}" "${${__EXT_VARNAME}}" __FEATURE)
			endif()
			set(${__OUT_ARGS}_${__VAR} "${${__EXT_VARNAME}}" PARENT_SCOPE)
			message(STATUS "_read_variables_from_cache(): Setting ${__OUT_ARGS}__SRC_${__VAR}: ${__SOURCE}")
			set(${__OUT_ARGS}__SRC_${__VAR} "${__SOURCE}" PARENT_SCOPE)
		else()
			set(${__OUT_ARGS}_${__VAR} "${${__ARGS}_${__VAR}}" PARENT_SCOPE)
		endif()
	endforeach()
	set(${__OUT_ARGS}__LIST "${${__ARGS}__LIST}" PARENT_SCOPE)
	set(${__OUT_ARGS}__LIST_MODIFIERS "${${__ARGS}__LIST_MODIFIERS}" PARENT_SCOPE)
	
endfunction()

function(_verify_parameter NAME CONTEXT CONTAINER TYPE VALUE IS_FEATURE)
#When IS_FEATURE is set, there is smaller set of valid type+container combinations
	set(VALID_CONTAINERS OPTION SCALAR VECTOR)
	set(VALID_TYPES INTEGER PATH STRING BOOL)
	if(NOT "${TYPE}" MATCHES "^CHOICE\(.+\)$" AND NOT "${TYPE}" IN_LIST VALID_TYPES)
		message(FATAL_ERROR "Wrong type for variable ${NAME} ${CONTEXT}. Must be INTEGER, PATH, STRING or CHOICE(opt1,opt2,...,optN) format, but got ${TYPE}")
	endif()
	if(NOT "${CONTAINER}" IN_LIST VALID_CONTAINERS)
		message(FATAL_ERROR "Wrong container for variable ${NAME} ${CONTEXT}. Container must be one of OPTION SCALAR or VECTOR, but got ${CONTAINER}")
	endif()
	if("${CONTAINER}" STREQUAL "OPTION")
		if(NOT "${TYPE}" STREQUAL "BOOL")
			message(FATAL_ERROR "Container OPTION can only contain boolean variables. Please specify type of the variable as BOOL in the definition of ${NAME} ${CONTEXT}")
		endif()
		_verify_value("${NAME}" "${CONTEXT}" BOOL "${VALUE}" ${IS_FEATURE})
	else()
		foreach(VAL IN LISTS VALUE)
			_verify_value("${NAME}" "${CONTEXT}" "${TYPE}" "${VAL}" ${IS_FEATURE})
		endforeach()
	endif()
endfunction()

function(_verify_value NAME CONTEXT TYPE VALUE IS_FEATURE)
	if("${TYPE}" STREQUAL "INTEGER")
		if(NOT "${VALUE}" MATCHES "^[0-9]+$")
			message(FATAL_ERROR "Wrong value of the variable ${NAME} ${CONTEXT}. Expected integer, but got ${VALUE}")
		endif()
	elseif("${TYPE}" STREQUAL "BOOL")
		set(VALID_YES ON YES TRUE Y)
		set(VALID_NO 0 OFF NO FALSE N IGNORE NOTFOUND)
		set(VALID_ALL ${VALID_YES} ${VALID_NO})
		if ("${VALUE}" MATCHES "^[1-9][0-9]*$")
			return() #OK, yes
		endif()
		if("${VALUE}" IN_LIST VALID_ALL)
			return() #OK, yes or no
		endif()
		if("${VALUE}" STREQUAL "")
			return() #OK, no
		endif()
		message(FATAL_ERROR "Wrong value of the variable ${NAME} ${CONTEXT}. Expected BOOL, but got ${VALUE}")
	elseif("${TYPE}" STREQUAL "STRING")
		return() #String is always ok
	elseif("${TYPE}" STREQUAL "PATH")
		return() #Path is always ok - for now...;-)
	else()
#		message(FATAL_ERROR "string(REGEX_MATCH \"^CHOICE\\((.*)\\)$\" CHOICES \"${TYPE}\")")
		string(REGEX REPLACE "^CHOICE\\((.*)\\)$" "\\1" CHOICES "${TYPE}")
		if(NOT CHOICES)
			message(FATAL_ERROR "Wrong format of type: ${TYPE} ${CONTEXT} for variable ${NAME}.")
		endif()
		string(REPLACE ":" ";" CHOICES_LIST "${CHOICES}")
		if(NOT "${VALUE}" IN_LIST CHOICES_LIST)
			message(FATAL_ERROR "Value \"${VALUE}\" of the variable ${NAME} not in choices ${CHOICES_LIST}")
		endif()
		return() #OK
	endif()
endfunction()

function(_read_variables_from_args __PARS __ARGS __OUT_ARGS ${ARGN})
	set(__OPTIONS)
	set(__oneValueArgs )
	set(__multiValueArgs)
	
	foreach(__PAR IN LISTS ${__PARS}__LIST)
		if("${${__PARS}_${__PAR}__CONTAINER}" STREQUAL "OPTION")
			list(APPEND __OPTIONS ${__PAR})
		elseif("${${__PARS}_${__PAR}__CONTAINER}" STREQUAL "SCALAR")
			list(APPEND __oneValueArgs ${__PAR})
		elseif("${${__PARS}_${__PAR}__CONTAINER}" STREQUAL "VECTOR")
			list(APPEND __multiValueArgs ${__PAR})
		else()
			message(FATAL_ERROR "Wrong type of container (${__PARS}_${__PAR}__CONTAINER = ${${__PARS}_${__PAR}__CONTAINER}) for variable ${__PAR}")
		endif()
	endforeach()
	
	cmake_parse_arguments(__PARSED "${__OPTIONS}" "${__oneValueArgs}" "${__multiValueArgs}" ${ARGN})
#	message(STATUS "_read_variables_from_args(): __multiValueArgs:${__multiValueArgs}")
	set(__unparsed ${__PARSED_UNPARSED_ARGUMENTS})
	if(__unparsed)
		message(FATAL_ERROR "Undefined variables passed as arguments: ${__unparsed} (all variables: ${ARGN})")
	endif()
	foreach(__OPTION IN LISTS __OPTIONS)
		if(NOT __PARSED_${__OPTION})
			unset(__PARSED_${__OPTION})
		endif()
	endforeach()
#	message(FATAL_ERROR "${__ARGS}__LIST: ${${__ARGS}__LIST}")
	_read_variables_from_cache(${__PARS} ${__ARGS} __PARSED args __IN_ARGS)
#	message(STATUS "_read_variables_from_args(): __IN_ARGS__SRC_BCTYPE: ${__IN_ARGS__SRC_BCTYPE}")
#	message(FATAL_ERROR "__IN_ARGS__LIST: ${__IN_ARGS__LIST}")
	_pass_arguments_higher(__IN_ARGS ${__OUT_ARGS})
endfunction()




# Function injects variables from __ARG_IN into the calling scope, so the variables are ready to be used by user-supplied function 
# generate_targets() or declare_dependencies()
function(_instantiate_variables __ARGS __ARGS_LIST)
	if(NOT __ARGS_LIST)
		return()
		message(FATAL_ERROR "No variables to instantiate")
	endif()
	foreach(__VAR IN LISTS __ARGS_LIST)
		set(${__VAR} "${${__ARGS}_${__VAR}}" PARENT_SCOPE)
	endforeach()
endfunction()

function(_make_instance_id __TEMPLATE_NAME __ARGS __SALT __OUT __OUT_SOURCE)
	get_property(__TEMPLATE_NAMES GLOBAL PROPERTY __TEMPLATE_NAMES_${__TEMPLATE_NAME})
	_calculate_hash(${__ARGS} "${${__ARGS}__LIST}" "${__SALT}" __HASH __HASH_SOURCE)
	if("${__HASH}" STREQUAL "")
		set(${__OUT} "${__TEMPLATE_NAME}")
	else()
		set(${__OUT} "${__TEMPLATE_NAME}_${__HASH}")
	endif()
	
	_serialize_variables(${__ARGS} "${${__ARGS}__LIST}" __TMP_SER)
#	message(STATUS "_make_instance_id(): ${__TEMPLATE_NAME} with args ${__TMP_SER} got hash ${${__OUT}} based on source ${__HASH_SOURCE}")
	set(${__OUT} "${${__OUT}}" PARENT_SCOPE)
	set(${__OUT_SOURCE} "${__HASH_SOURCE}" PARENT_SCOPE)
endfunction()

function(_make_instance_name __INSTANCE_ID __OUT)
#	message(STATUS "_make_instance_name(): called for __INSTANCE_ID: ${__INSTANCE_ID}")
	_get_target_behavior(__TARGET_BEHAVIOR)
	if("${__TARGET_BEHAVIOR}" STREQUAL "GATHERING_DEPENDENCIES")
		message(FATAL_ERROR "Internal error. Function _make_instance_name should never be called during gathering dependencies phase")
	endif()
	if("${__INSTANCE_ID}" STREQUAL "")
		message(FATAL_ERROR "__INSTANCE_ID cannot be empty")
	endif()
	_retrieve_instance_data(${__INSTANCE_ID} TARGET_NAME __TARGET_NAME)
	if(NOT "${__TARGET_NAME}" STREQUAL "")
		set(${__OUT} "${__TARGET_NAME}" PARENT_SCOPE)
#		message(STATUS "_make_instance_name(): short-circuit exit with __TARGET_NAME: ${__TARGET_NAME} for __INSTANCE_ID: ${__INSTANCE_ID}")
		return()
	endif()
	
	_retrieve_instance_data(${__INSTANCE_ID} FEATUREBASE __HASH)
	_retrieve_instance_data(${__INSTANCE_ID} TEMPLATE_FEATUREBASES __TEMPLATE_HASHES)
	list(LENGTH __TEMPLATE_HASHES __NUMBER_OF_TARGETS)
	if("${__NUMBER_OF_TARGETS}" STREQUAL "")
#		set(__NUMBER_OF_TARGETS 1)
	endif()
	if("${__NUMBER_OF_TARGETS}" STREQUAL "0")
		message(FATAL_ERROR "Internal beetroot error: cannot have empty TEMPLATE_FEATUREBASES")
	endif()

	_retrieve_instance_data(${__INSTANCE_ID} I_TEMPLATE_NAME __TEMPLATE_NAME)
#	message(STATUS "_make_instance_name(): __NUMBER_OF_TARGETS in ${__TEMPLATE_NAME}: ${__NUMBER_OF_TARGETS}")
	string(TOLOWER ${__TEMPLATE_NAME} __TEMPLATE_NAME_SMALL)
	string(REPLACE "::" "__" __TEMPLATE_NAME_VAR "${__TEMPLATE_NAME}")
	if( "${__HASH}" IN_LIST __TEMPLATE_HASHES)
		if( ${__NUMBER_OF_TARGETS} GREATER 1)
			list(FIND __TEMPLATE_HASHES "${__HASH}" __LENGTH_P1 )
			math(EXPR __LENGTH_P1 "${__LENGTH_P1} + 1")
		else()
			set(__LENGTH_P1)
		endif()
		set(__TARGET_NAME "${__TEMPLATE_NAME_SMALL}${__LENGTH_P1}")
	else()
		if( ${__NUMBER_OF_TARGETS} GREATER 1)
			list(LENGTH __TEMPLATE_HASHES __LENGTH)
			math(EXPR __LENGTH_P1 "${__LENGTH} + 1")
			set(__TARGET_NAME "${__TEMPLATE_NAME_SMALL}${__LENGTH_P1}")
		else()
			set(__TARGET_NAME "${__TEMPLATE_NAME_SMALL}")
		endif()
	endif()
#	message(STATUS "_make_instance_name(): ${__TEMPLATE_NAME} with hash ${__HASH} got its instance name ${__TARGET_NAME}")
	set(${__OUT} "${__TARGET_NAME}" PARENT_SCOPE)
	_set_property_to_db(INSTANCEDB ${__INSTANCE_ID} TARGET_NAME "${__TARGET_NAME}")
endfunction()

function(_make_cmake_args __PARS __ARGS __ARGS_LIST __OUT_CMAKE_ARGS)
#	message(STATUS "_make_cmake_args(): __PARS: ${__PARS} __ARGS: ${__ARGS} __ARGS_LIST: ${__ARGS_LIST}")
	set(__CMAKE_ARGS)
	foreach(__VAR IN LISTS __ARGS_LIST)
#		message(STATUS "_make_cmake_args(): processing ${__ARGS}_${__VAR}. Container ${__PARS}_${__VAR}__CONTAINER: ${${__PARS}_${__VAR}__CONTAINER}") # Container ${__PARS}_${__VAR}_CONTAINER: ${${__PARS}_${__VAR}_CONTAINER}, ${__PARS}_${__VAR}_TYPE: ${{__PARS}_${__VAR}_TYPE}
		if("${${__PARS}_${__VAR}__CONTAINER}" STREQUAL "OPTION" )	
			if(${__ARGS}_${__VAR})
				list(APPEND __CMAKE_ARGS "-D${__VAR}:BOOL=ON")
			else()
				list(APPEND __CMAKE_ARGS "-D${__VAR}:BOOL=OFF")
			endif()
		elseif("${${__PARS}_${__VAR}__TYPE}" STREQUAL "INTEGER")
			list(APPEND __CMAKE_ARGS "-D${__VAR}:STRING=${${__ARGS}_${__VAR}}")
		elseif("${${__PARS}_${__VAR}__TYPE}" STREQUAL "BOOL")
			list(APPEND __CMAKE_ARGS "-D${__VAR}:BOOL=${${__ARGS}_${__VAR}}")
		else()
			message(FATAL_ERROR "Unknown way to pass an argument ${__VAR} into the cmake, because it is ${${__PARS}_${__VAR}__CONTAINER} of type ${${__PARS}_${__VAR}__TYPE}")
		endif()
	endforeach()
#	message(STATUS "_make_cmake_args(): finished processing. ${__OUT_CMAKE_ARGS}: ${__CMAKE_ARGS}") 
	set(${__OUT_CMAKE_ARGS} "${__CMAKE_ARGS}" PARENT_SCOPE)
endfunction()

#Function ignores information about which parameters are modifiers.
function(_serialize_variables __ARGS __ARGS_LIST __OUT_SERIALIZED)
	set(OUT)
#	message(STATUS "_serialize_variables(): Serializing variables: ${${__ARGS}__LIST}...")
	foreach(__VAR IN LISTS __ARGS_LIST)
#		if("${__VAR}" STREQUAL "VERSION" AND "${${__ARGS}_${__VAR}}" STREQUAL "KUC")
#			message(FATAL_ERROR "OJOJ: ${__ARGS}_${__VAR}: ${${__ARGS}_${__VAR}}")
#		endif()
		string(REPLACE ";" ":" ${__ARGS}_${__VAR} "${${__ARGS}_${__VAR}}")
		if(OUT)
			set(OUT "${OUT};")
		endif()
		set(OUT "${OUT}${__VAR};${${__ARGS}_${__VAR}}")
	endforeach()
	set(${__OUT_SERIALIZED} "${OUT}" PARENT_SCOPE)
#	message(STATUS "_serialize_variables():... serialized string: \"${OUT}\"")
endfunction()

#Function ignores information about which parameters are modifiers.
function(_serialize_parameters __PARS __OUT_SERIALIZED)
	set(OUT)
#	message(STATUS "_serialize_parameters(): Serializing variables: ${${__ARGS}__LIST}...")
	foreach(__PAR IN LISTS ${__PARS}__LIST)
		if(OUT)
			set(OUT "${OUT};")
		endif()
		set(OUT "${OUT}${__PAR};${${__PARS}_${__PAR}__CONTAINER};${${__PARS}_${__PAR}__TYPE}")
	endforeach()
	set(${__OUT_SERIALIZED} "${OUT}" PARENT_SCOPE)
#	message(STATUS "_serialize_parameters():... serialized string: \"${OUT}\"")
endfunction()

function(_unserialize_variables __SERIALIZED __OUT_ARGS)
	set(__LIST)
	if(__SERIALIZED)
#		message(STATUS "_unserialize_variables, __SERIALIZED: ${__SERIALIZED} ")
		list(LENGTH __SERIALIZED __TMP)
		math(EXPR __ARGS_LENGTH "${__TMP} / 2 - 1")
		math(EXPR __ARGS_CHECK "${__TMP} % 2")
		if(NOT "${__ARGS_CHECK}" STREQUAL "0")
			message(FATAL_ERROR "Wrong number of elements in the serialized arguments ${__SERIALIZED}. Expected number of elements divisible by 2, but got ${__TMP} elements.")
		endif()

		foreach(__VAR_NR RANGE "${__ARGS_LENGTH}")
			math(EXPR __TMP "${__VAR_NR}*2")
			list(GET __SERIALIZED ${__TMP} __VARNAME)
			list(APPEND __LIST ${__VARNAME})
		
			math(EXPR __TMP "${__VAR_NR}*2 + 1")
			list(GET __SERIALIZED ${__TMP} __VALUE)
			string(REPLACE ":" ";" __VALUE "${__VALUE}")
			set(${__OUT_ARGS}_${__VARNAME} "${__VALUE}" PARENT_SCOPE)
#			message(STATUS "_unserialize_variables(): __VARNAME: ${__VARNAME}, __VALUE: \"${__VALUE}\"")
		endforeach()
	endif()
	set(${__OUT_ARGS}__LIST "${__LIST}" PARENT_SCOPE)
endfunction()

function(_unserialize_parameters __SERIALIZED __OUT_PARS)
	set(__LIST)
	if(__SERIALIZED)
#		message(STATUS "_unserialize_parameters(): __SERIALIZED: ${__SERIALIZED} ")
		list(LENGTH __SERIALIZED __TMP)
		math(EXPR __PARS_LENGTH "${__TMP} / 3 - 1")
		math(EXPR __PARS_CHECK "${__TMP} % 3")
		if(NOT "${__PARS_CHECK}" STREQUAL "0")
			message(FATAL_ERROR "Wrong number of elements in the serialized arguments ${__SERIALIZED}. Expected number of elements divisible by 2, but got ${__TMP} elements.")
		endif()
		foreach(__PAR_NR RANGE "${__PARS_LENGTH}")
			math(EXPR __TMP "${__PAR_NR}*3")
			list(GET __SERIALIZED ${__TMP} __VARNAME)
			list(APPEND __LIST ${__VARNAME})
		
			math(EXPR __TMP "${__PAR_NR}*3 + 1")
			list(GET __SERIALIZED ${__TMP} __CONTAINER)
			set(${__OUT_PARS}_${__VARNAME}__CONTAINER "${__CONTAINER}" PARENT_SCOPE)

			math(EXPR __TMP "${__PAR_NR}*3 + 2")
			list(GET __SERIALIZED ${__TMP} __TYPE)
			set(${__OUT_PARS}_${__VARNAME}__TYPE "${__TYPE}" PARENT_SCOPE)
#			message(STATUS "_unserialize_parameters(): __VARNAME: ${__VARNAME}, __CONTAINER: ${__CONTAINER}, __TYPE: ${__TYPE}")
		endforeach()
	endif()
	set(${__OUT_PARS}__LIST "${__LIST}" PARENT_SCOPE)
#	message(STATUS "_unserialize_parameters(): ${__OUT_PARS}__LIST: ${__LIST}")
endfunction()

function(_parse_file_options __INSTANCE_ID __TARGETS_CMAKE_PATH __IS_TARGET_FIXED __TEMPLATE_OPTIONS __OUT_SINGLETON_TARGETS __OUT_NO_TARGETS __OUT_LANGUAGES __OUT_NICE_NAME __OUT_EXPORTED_VARIABLES)
	set(__OPTIONS SINGLETON_TARGETS NO_TARGETS)
	set(__oneValueArgs NICE_NAME)
	set(__multiValueArgs LANGUAGES EXPORTED_VARIABLES)
	
	set(__PARSED_LANGUAGES)
	set(__PARSED_SINGLETON_TARGETS)
	set(__PARSED_NO_TARGETS)
	cmake_parse_arguments(__PARSED "${__OPTIONS}" "${__oneValueArgs}" "${__multiValueArgs}" ${__TEMPLATE_OPTIONS})
	set(__unparsed ${__PARSED_UNPARSED_ARGUMENTS})
	if(__unparsed)
		message(FATAL_ERROR "Undefined TEMPLATE_OPTIONS in ${__TARGETS_CMAKE_PATH}: ${__unparsed}")
	endif()
	
#	message(STATUS "_parse_file_options(): __TEMPLATE_OPTIONS: ${__TEMPLATE_OPTIONS}")
	if(__PARSED_LANGUAGES)
#		message(STATUS "_parse_file_options(): __PARSED_LANGUAGES: ${__PARSED_LANGUAGES}")
		set(__CMAKE_LANGUAGES CXX C CUDA Fortran ASM)
		foreach(__LANGUAGE IN LISTS __PARSED_LANGUAGES)
			if(NOT ${__LANGUAGE} IN_LIST __CMAKE_LANGUAGES)
				message(FATAL_ERROR "Option LANGUAGES in TEMPLATE_OPTIONS defined in ${__TARGETS_CMAKE_PATH} contains unknown language \"${__LANGUAGE}\".")
			endif()
		endforeach()
		set(${__OUT_LANGUAGES} ${__PARSED_LANGUAGES} PARENT_SCOPE)
	else()
		set(${__OUT_LANGUAGES} "" PARENT_SCOPE)
	endif()
	
	_make_path_hash(${__TARGETS_CMAKE_PATH} __PATH_HASH)
	if(__PARSED_SINGLETON_TARGETS)
		set(${__OUT_SINGLETON_TARGETS} 1 PARENT_SCOPE)
		if(NOT __IS_TARGET_FIXED)
			message(FATAL_ERROR "When using SINGLETON_TARGETS option, please list all targets using ENUM_TARGETS rather than ENUM_TEMPLATES.")
		endif()
	else()
		set(${__OUT_SINGLETON_TARGETS} 0 PARENT_SCOPE)
	endif()

	if(__PARSED_NO_TARGETS)
		set(${__OUT_NO_TARGETS} 1 PARENT_SCOPE)
	else()
		set(${__OUT_NO_TARGETS} 0 PARENT_SCOPE)
	endif()

	if(__PARSED_NICE_NAME)
		set(${__OUT_NICE_NAME} "${__PARSED_NICE_NAME}" PARENT_SCOPE)
	else()
		set(${__OUT_NICE_NAME} "" PARENT_SCOPE)
	endif()
	
	if(__PARSED_EXPORTED_VARIABLES)
		set(${__OUT_EXPORTED_VARIABLES} "${__PARSED_EXPORTED_VARIABLES}" PARENT_SCOPE)
	else()
		set(${__OUT_EXPORTED_VARIABLES} "" PARENT_SCOPE)
	endif()
endfunction()

function(_get_nice_name __INSTANCE_ID __OUT_NICE_NAME)
	_retrieve_instance_data(${__INSTANCE_ID} NICE_NAME __NICE_NAME)
	if(__NICE_NAME)
		set(${__OUT_NICE_NAME} "${__NICE_NAME}" PARENT_SCOPE)
		return()
	endif()
	_retrieve_instance_data(${__INSTANCE_ID} G_INSTANCES __SIBLINGS)
	set(__SIB_TEMPLATES)
	foreach(__SIB_ID IN LISTS __SIBLINGS)
		_retrieve_instance_data(${__SIB_ID} EXTERNAL_INFO __EXTERNAL)
		if(__EXTERNAL)
			_parse_external_info("${__EXTERNAL_INFO}" "${__TARGETS_CMAKE_PATH}" NAME __NICE_NAME)
			if(__NICE_NAME)
				set(__TEMPLATE "${__NICE_NAME}")
			else()
				_retrieve_instance_data(${__SIB_ID} I_TEMPLATE_NAME __TEMPLATE)
			endif()
		else()
			_retrieve_instance_data(${__SIB_ID} I_TEMPLATE_NAME __TEMPLATE)
		endif()
		if(NOT __SIB_TEMPLATES)
			set(__SIB_TEMPLATES "${__TEMPLATE}")
		elseif(NOT "${__TEMPLATE}" IN_LIST __SIB_TEMPLATES)
			list(APPEND __SIB_TEMPLATES "${__TEMPLATE}")
		endif()
	endforeach()
	nice_list_output(LIST "${__SIB_TEMPLATES}" OUTVAR __NICE_LIST)
	set(${__OUT_NICE_NAME} "${__NICE_LIST}")
endfunction()

function(_get_nice_dependencies_name __INSTANCE_ID __OUTVAR)
	_retrieve_instance_data(${__INSTANCE_ID} I_PARENTS __PARENTS)
	set(__DEPS)
	foreach(__PARENT_ID IN LISTS __PARENTS)
		_get_nice_name(${__PARENT_ID} __DEP)
		list(APPEND __DEPS "\"${__DEP}\"")
	endforeach()
	nice_list_output(LIST "${__DEPS}" OUTVAR __OUT)
	set(${__OUTVAR} "${__OUT}" PARENT_SCOPE )
endfunction()

