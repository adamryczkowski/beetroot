# _get_variables(<path to targets.cmake> <out_arguments_prefix> <out_template_names> <out_DEFINE_EXTERNAL_PROJECT> <Args...>)
#
# Parses targets.cmake and gets the actual value of the variables based on the 
# 1. defaults declared in targets.cmake,
# 2. overriden by pre-existing CMake variables which names matches the declared parameters in the targets.cmake
# 3. overriden by named arguments passed in Args... .
# The values are checked for validity and stored in the standard format in prefix out_arguments_prefix. 
# Moreover it saves template names declared in the targets.cmake (in ${out_template_names}) and information about external project in ${out_external}.
#
# The algorithm allows for default values for parameters to be dependent on other variables, which allows to encode parameter transformation logic, because the
# values for the variables will be taken _after_ injecting the cached variables and - which is non trivial - the arguments Args... (which override everything).
#
# Moreover, the mentioned algorithm is run several times, as long as the names of the variables stabilise. That means, that variable defined as 
#
# set(DEFINE_PARAMETERS 
#	NEVER_ENDING_INTEGER	SCALAR	INTEGER "${NEVER_ENDING_INTEGET}+1")
#
# Will never parse, because on each run of the algorithm the value for NEVER_ENDING_INTEGET will be different. 
#
# But this is usefull for e.g.
#
# if("${MY_OTHER_ARG}" STREQUAL "1" )
#	set(TMP "SINGULAR")
# else()
#	set(TMP "PLURAL")
# endif()
#
# set(DEFINE_PARAMETERS 
#	MY_OTHER_ARG	SCALAR	INTEGER 1
#	ARG	SCALAR	CHOICE(SINGULAR;PLURAL) ${TMP}
# )
function(_get_variables __TARGETS_CMAKE_PATH __EXISTING_VARIABLES_PREFIX __OUT_VARIABLE_DIC __OUT_PARAMETERS_DIC __OUT_TEMPLATE_NAMES __OUT_EXTERNAL_PROJECT_INFO __OUT_IS_TARGET_FIXED)
	set(__ARGUMENT_HASH)
	set(__ITERATION_COUNT 0)

	set(__ARGUMENT_HASH_OLD "")
	foreach(__ITERATION RANGE 10)
		_read_parameters("${__TARGETS_CMAKE_PATH}" __PARS __ARGS __IN_TEMPLATE_NAMES __IN_EXTERNAL_PROJECT_INFO __IN_IS_TARGET_FIXED)
		if(NOT __PARS__LIST)
			break() #no variables
		endif()
		_read_variables_from_cache(__PARS __ARGS "" __ARGS)
		_read_variables_from_args(__PARS __ARGS __ARGS ${ARGN})
		_calculate_hash(__ARGS "${__ARGS__LIST}" "X" __ARGUMENT_HASH_NEW)
		if("${__ARGUMENT_HASH_NEW}" STREQUAL "${__ARGUMENT_HASH_OLD}")
			break()
		endif()
		set(__ARGUMENT_HASH_OLD "${__ARGUMENT_HASH_NEW}")
	endforeach()
#	if("${__TARGETS_CMAKE_PATH}" MATCHES "/serialbox.cmake")
#		message(WARNING "_get_variables(): __TARGETS_CMAKE_PATH: ${__TARGETS_CMAKE_PATH} __IN_EXTERNAL_PROJECT_INFO: ${__IN_EXTERNAL_PROJECT_INFO} __IN_TEMPLATE_NAMES: ${__IN_TEMPLATE_NAMES} __OUT_EXTERNAL_PROJECT_INFO: ${__OUT_EXTERNAL_PROJECT_INFO}")
#	else()
#		message(STATUS "_get_variables(): __TARGETS_CMAKE_PATH: ${__TARGETS_CMAKE_PATH} __IN_EXTERNAL_PROJECT_INFO: ${__IN_EXTERNAL_PROJECT_INFO} __IN_TEMPLATE_NAMES: ${__IN_TEMPLATE_NAMES}")
#	endif()
	
	if(NOT "${__ARGUMENT_HASH_NEW}" STREQUAL "${__ARGUMENT_HASH_OLD}")
		message(FATAL_ERROR "Could not converge the values of arguments after ${__ITERATION} iterations")
	endif()
	
	_pass_arguments_higher(__ARGS ${__OUT_VARIABLE_DIC})
	_pass_parameters_higher(__PARS ${__OUT_PARAMETERS_DIC})
	set(${__OUT_TEMPLATE_NAMES} "${__IN_TEMPLATE_NAMES}" PARENT_SCOPE)
	set(${__OUT_EXTERNAL_PROJECT_INFO} "${__IN_EXTERNAL_PROJECT_INFO}" PARENT_SCOPE)
	set(${__OUT_IS_TARGET_FIXED} "${__IN_IS_TARGET_FIXED}" PARENT_SCOPE)
endfunction()

macro(_pass_arguments_higher __IN_PREFIX __OUT_PREFIX)
#	message(FATAL_ERROR "${__IN_PREFIX}__LIST: ${${__IN_PREFIX}__LIST}")
	foreach(__VAR IN LISTS ${__IN_PREFIX}__LIST)
#		message(FATAL_ERROR "set(${__OUT_PREFIX}_${__VAR} \"${${__IN_PREFIX}_${__VAR}}\" PARENT_SCOPE)")
		set(${__OUT_PREFIX}_${__VAR} "${${__IN_PREFIX}_${__VAR}}" PARENT_SCOPE)
	endforeach()
	set(${__OUT_PREFIX}__LIST "${${__IN_PREFIX}__LIST}" PARENT_SCOPE)
	set(${__OUT_PREFIX}__LIST_MODIFIERS "${${__IN_PREFIX}__LIST_MODIFIERS}" PARENT_SCOPE)
endmacro()

macro(_pass_parameters_higher __IN_PREFIX __OUT_PREFIX)
	foreach(__VAR IN LISTS ${__IN_PREFIX}__LIST)
		set(${__OUT_PREFIX}_${__VAR}__CONTAINER "${${__IN_PREFIX}_${__VAR}__CONTAINER}" PARENT_SCOPE)
		set(${__OUT_PREFIX}_${__VAR}__TYPE "${${__IN_PREFIX}_${__VAR}__TYPE}" PARENT_SCOPE)
	endforeach()
	set(${__OUT_PREFIX}__LIST "${${__IN_PREFIX}__LIST}" PARENT_SCOPE)
	set(${__OUT_PREFIX}__LIST_MODIFIERS "${${__IN_PREFIX}__LIST_MODIFIERS}" PARENT_SCOPE)
endmacro()

macro(_parse_parameters __DEFINITIONS __OUT_ARGS __OUT_PARS __TARGETS_CMAKE_PATH)
	set(__DEFINITIONS ${__DEFINITIONS})
	list(LENGTH __DEFINITIONS __TMP)
	math(EXPR __PARS_LENGTH "${__TMP} / 4 - 1")
	math(EXPR __PARS_CHECK "${__TMP} % 4")
	if(NOT "${__PARS_CHECK}" STREQUAL "0")
		message(FATAL_ERROR "Wrong number of elements in the DEFINE_PARAMETERS variable defined in ${__TARGETS_CMAKE_PATH}. Expected number of elements divisible by 4, but got ${__TMP} elements: ${__DEFINITIONS}")
	endif()
	if(NOT "${__TMP}" STREQUAL 0)
		set(__LIST)
#		message(STATUS "_parse_parameters(), __PARS_LENGTH=${__PARS_LENGTH}")
		foreach(__VAR_NR RANGE "${__PARS_LENGTH}")
			math(EXPR __TMP "${__VAR_NR}*4")
			list(GET __DEFINITIONS ${__TMP} __VAR_NAME )
			if( "${__VAR_NAME}" MATCHES "^_.*$")
				message(FATAL_ERROR "Cannot declare variables that start with underscore (like \"${__VARNAME}\"). Error encountered in ${__TARGETS_CMAKE_PATH}.")
			endif()
			if(NOT "${__VAR_NAME}" MATCHES "^[A-Za-z][A-Za-z0-9_]*$")
				message(FATAL_ERROR "Variables must start with the letter and consit only from letters, digits and underscores, not like \"${__VARNAME}\" encounterd in ${__TARGETS_CMAKE_PATH}.")
			endif()
			if("${__VAR_NAME}" IN_LIST ${__OUT_ARGS}__LIST)
				message(FATAL_ERROR "Multiple definitions of the same variable/modifier (here: \"${__VARNAME}\") are not allowed. Modifiers and variables share the same namespace. Error encountered in ${__TARGETS_CMAKE_PATH}.")
			endif()
			math(EXPR __TMP "${__VAR_NR}*4 + 1")
			list(GET __DEFINITIONS ${__TMP} ${__OUT_PARS}_${__VAR_NAME}__CONTAINER)
			math(EXPR __TMP "${__VAR_NR}*4 + 2")
			list(GET __DEFINITIONS ${__TMP} ${__OUT_PARS}_${__VAR_NAME}__TYPE)
			math(EXPR __TMP "${__VAR_NR}*4 + 3")
			list(GET __DEFINITIONS ${__TMP} __VAR_DEFAULT)
			if("${${__OUT_PARAMETERS_PREFIX}_${__VAR_NAME}__CONTAINER}" STREQUAL "VECTOR")
				string(REPLACE ":" ";" __VAR_DEFAULT "${__VAR_DEFAULT}")
			endif()
			_verify_parameter("${__VAR_NAME}" "as default parameter in ${__TARGETS_CMAKE_PATH}" "${${__OUT_PARS}_${__VAR_NAME}__CONTAINER}" "${${__OUT_PARS}_${__VAR_NAME}__TYPE}" "${__VAR_DEFAULT}")
			set(${__OUT_ARGS}_${__VAR_NAME} "${__VAR_DEFAULT}")
			list(APPEND ${__OUT_ARGS}__LIST "${__VAR_NAME}")
			list(APPEND ${__OUT_PARS}__LIST "${__VAR_NAME}")
#			message(STATUS "Found variable ${__VAR_NAME} with container ${__OUT_PARS}_${__VAR_NAME}__CONTAINER: ${${__OUT_PARS}_${__VAR_NAME}__CONTAINER}")
		endforeach()
	endif()
endmacro()

# Reads, parses and checks parameter definition from targets.cmake.
# Also initializes argument list with the default value of each parameter.
function(_read_parameters __TARGETS_CMAKE_PATH __OUT_PARAMETERS_PREFIX __OUT_ARGUMENTS_PREFIX __OUT_TEMPLATE_NAMES __OUT_EXTERNAL_PROJECT_INFO __OUT_IS_TARGET_FIXED)
	_read_targets_file("${__TARGETS_CMAKE_PATH}" __READ_PREFIX __IS_TARGET_FIXED)
	set(${__OUT_ARGUMENTS_PREFIX}__LIST)
	set(${__OUT_PARAMETERS_PREFIX}__LIST)
	set(${__OUT_ARGUMENTS_PREFIX}__LIST_MODIFIERS)
	set(${__OUT_PARAMETERS_PREFIX}__LIST_MODIFIERS)
	_parse_parameters("${__READ_PREFIX_DEFINE_MODIFIERS}" ${__OUT_ARGUMENTS_PREFIX} ${__OUT_PARAMETERS_PREFIX} "${__TARGETS_CMAKE_PATH}")
#	message(STATUS "__READ_PREFIX_DEFINE_MODIFIERS: ${__READ_PREFIX_DEFINE_MODIFIERS}")
#	message(FATAL_ERROR "${__OUT_ARGUMENTS_PREFIX}__LIST: ${${__OUT_ARGUMENTS_PREFIX}__LIST}")
	set(${__OUT_PARAMETERS_PREFIX}__LIST_MODIFIERS "${${__OUT_PARAMETERS_PREFIX}__LIST}")
	set(${__OUT_ARGUMENTS_PREFIX}__LIST_MODIFIERS "${${__OUT_ARGUMENTS_PREFIX}__LIST}")
	_parse_parameters("${__READ_PREFIX_DEFINE_PARAMETERS}" ${__OUT_ARGUMENTS_PREFIX} ${__OUT_PARAMETERS_PREFIX} "${__TARGETS_CMAKE_PATH}")
#	message(FATAL_ERROR "${__OUT_PARAMETERS_PREFIX}_WYBOR__CONTAINER: ${${__OUT_PARAMETERS_PREFIX}_WYBOR__CONTAINER}")
	_pass_arguments_higher(${__OUT_ARGUMENTS_PREFIX} ${__OUT_ARGUMENTS_PREFIX})
	_pass_parameters_higher(${__OUT_PARAMETERS_PREFIX} ${__OUT_PARAMETERS_PREFIX})
	
	set(${__OUT_TEMPLATE_NAMES} "${__READ_PREFIX_ENUM_TEMPLATES}" PARENT_SCOPE)
	set(${__OUT_EXTERNAL_PROJECT_INFO} "${__READ_PREFIX_DEFINE_EXTERNAL_PROJECT}" PARENT_SCOPE)
	set(${__OUT_IS_TARGET_FIXED} "${__IS_TARGET_FIXED}" PARENT_SCOPE)
endfunction()


# Calculates hash of the ARGS prefix. 
# The hash is independent from the order in which ARGS is layed out, because it first sorts it.
# It also appends __EXTRA_STRING to the hashed string, so it can encode some extra information as well (e.g. template name)
function(_calculate_hash __PREFIX __VAR_LIST __EXTRA_STRING __OUT_HASH)
	set(__STRING_SO_FAR "${__EXTRA_STRING}")
#	message(WARNING "_calculate_hash(): __EXTRA_STRING=${__EXTRA_STRING} __LIST_MODIFIERS=${${__PREFIX}__LIST_MODIFIERS}")
	if(__VAR_LIST)
		list(SORT __VAR_LIST COMPARE STRING CASE INSENSITIVE ORDER ASCENDING)
		foreach(__ARG IN LISTS __VAR_LIST)
			set(__STRING_SO_FAR "${__STRING_SO_FAR};${${__PREFIX}_${__ARG}}")
		endforeach()
		string(MD5 __HASH "${__STRING_SO_FAR}")
		set(${__OUT_HASH} "${__HASH}" PARENT_SCOPE)
#		message(STATUS "_calculate_hash(): Calculated hash: ${__HASH}")
	else()
		set(${__OUT_HASH} "${__EXTRA_STRING}" PARENT_SCOPE)
	endif()
endfunction()


# _read_variables_from_cache(__PARS __ARGS __VALUES __OUT_ARGS)
#
# Iterates over all variables in __PARS, and combines the values taken from __ARGS with overrides taken as the same name, but with optional prefix __VALUES.
#
# It also validates the variable, if it is taken from __VALUES
function(_read_variables_from_cache __PARS __ARGS __VALUES __OUT_ARGS)
	foreach(__VAR IN LISTS ${__ARGS}__LIST)
		if(NOT "${${__VAR}}" STREQUAL "")
			set(__EXT_VARNAME ${__VAR})
		else()
			set(__EXT_VARNAME ${__VALUES}_${__VAR})
		endif()
		if(DEFINED ${__EXT_VARNAME})
#			message(FATAL_ERROR "_verify_parameter(\"${__VAR}\" \"as defined value ${__EXT_VARNAME}\" ${__PARS}_${__VAR}__CONTAINER=\"${${__PARS}_${__VAR}__CONTAINER}\" \"${${__PARS}_${__VAR}__TYPE}\" \"${${__EXT_VARNAME}}\"")
			_verify_parameter("${__VAR}" "as defined value ${__EXT_VARNAME}" "${${__PARS}_${__VAR}__CONTAINER}" "${${__PARS}_${__VAR}__TYPE}" "${${__EXT_VARNAME}}")
			set(${__OUT_ARGS}_${__VAR} "${${__EXT_VARNAME}}" PARENT_SCOPE)
		else()
			set(${__OUT_ARGS}_${__VAR} "${${__ARGS}_${__VAR}}" PARENT_SCOPE)
		endif()
	endforeach()
	set(${__OUT_ARGS}__LIST "${${__ARGS}__LIST}" PARENT_SCOPE)
	set(${__OUT_ARGS}__LIST_MODIFIERS "${${__ARGS}__LIST_MODIFIERS}" PARENT_SCOPE)
	
endfunction()

function(_verify_parameter NAME CONTEXT CONTAINER TYPE VALUE)
	set(VALID_CONTAINERS OPTION SCALAR VECTOR)
	set(VALID_TYPES INTEGER PATH STRING BOOL)
	if(NOT "${TYPE}" MATCHES "^CHOICE\(.+\)$" AND NOT "${TYPE}" IN_LIST VALID_TYPES)
		message(FATAL_ERROR "Wrong type for variable ${NAME} ${CONTEXT}. Must be INTEGER, PATH, STRING or CHOICE(opt1,opt2,...,optN) format, but got ${TYPE}")
	endif()
	if(NOT "${CONTAINER}" IN_LIST VALID_CONTAINERS)
		message(FATAL_ERROR "Wrong container for variable ${NAME} ${CONTEXT}. Container must be one of OPTION SCALAR or VECTOR, but got ${CONTAINER}")
	endif()
	if("${CONTAINER}" STREQUAL "OPTION")
		_verify_value("${VALUE}" BOOL "${NAME}")
	else()
		foreach(VAL IN LISTS VALUE)
			_verify_value("${NAME}" "${CONTEXT}" "${TYPE}" "${VAL}")
		endforeach()
	endif()
endfunction()

function(_verify_value NAME CONTEXT TYPE VALUE)
	if("${TYPE}" STREQUAL "INTEGER")
		if(NOT "${VALUE}" MATCHES "^[0-9]+$")
			message(FATAL_ERROR "Wrong value of the variable ${NAME} ${CONTEXT}. Expected integer, but got ${VALUE}")
		endif()
	elseif("${TYPE}" STREQUAL "BOOL")
		set(VALID_YES ON YES TRUE Y)
		set(VALID_NO 0 OFF NO FALSE N IGNORE NOTFOUND)
		set(VALID_ALL ${VALID_YES} ${VALID_NO})
		if ("${VALUE}" MATCHES "^[1-9][0-9]*$")
			return() #OK, yes
		endif()
		if("${VALUE}" IN_LIST VALID_ALL)
			return() #OK, yes or no
		endif()
		if("${VALUE}" STREQUAL "")
			return() #OK, no
		endif()
		message(FATAL_ERROR "Wrong value of the variable ${NAME} ${CONTEXT}. Expected BOOL, but got ${VALUE}")
	elseif("${TYPE}" STREQUAL "STRING")
		return() #String is always ok
	elseif("${TYPE}" STREQUAL "PATH")
		return() #Path is always ok - for now...;-)
	else()
#		message(FATAL_ERROR "string(REGEX_MATCH \"^CHOICE\\((.*)\\)$\" CHOICES \"${TYPE}\")")
		string(REGEX REPLACE "^CHOICE\\((.*)\\)$" "\\1" CHOICES "${TYPE}")
		if(NOT CHOICES)
			message(FATAL_ERROR "Wrong format of type: ${TYPE} ${CONTEXT} for variable ${NAME}.")
		endif()
		string(REPLACE ":" ";" CHOICES_LIST "${CHOICES}")
		if(NOT "${VALUE}" IN_LIST CHOICES_LIST)
			message(FATAL_ERROR "Value \"${VALUE}\" of the variable ${NAME} not in choices ${CHOICES_LIST}")
		endif()
		return() #OK
	endif()
endfunction()

function(_read_variables_from_args __PARS __ARGS __OUT_ARGS ${ARGN})
	set(__OPTIONS)
	set(__oneValueArgs )
	set(__multiValueArgs)
	
	foreach(__PAR IN LISTS ${__PARS}__LIST)
		if("${${__PARS}_${__PAR}__CONTAINER}" STREQUAL "OPTION")
			list(APPEND __OPTIONS ${__PAR})
		elseif("${${__PARS}_${__PAR}__CONTAINER}" STREQUAL "SCALAR")
			list(APPEND __oneValueArgs ${__PAR})
		elseif("${${__PARS}_${__PAR}__CONTAINER}" STREQUAL "VECTOR")
			list(APPEND __multiValueArgs ${__PAR})
		else()
			message(FATAL_ERROR "Wrong type of container (${__PARS}_${__PAR}__CONTAINER = ${${__PARS}_${__PAR}__CONTAINER}) for variable ${__PAR}")
		endif()
	endforeach()
	
	cmake_parse_arguments(__PARSED "${__OPTIONS}" "${__oneValueArgs}" "${__multiValueArgs}" ${ARGN})

	set(__unparsed ${__PARSED_UNPARSED_ARGUMENTS})
	if(__unparsed)
		message(FATAL_ERROR "Undefined variables passed as arguments: ${__unparsed}")
	endif()
#	message(FATAL_ERROR "${__ARGS}__LIST: ${${__ARGS}__LIST}")
	_read_variables_from_cache(${__PARS} ${__ARGS} __PARSED __IN_ARGS)
#	message(FATAL_ERROR "__IN_ARGS__LIST: ${__IN_ARGS__LIST}")
	_pass_arguments_higher(__IN_ARGS ${__OUT_ARGS})
endfunction()




# Function injects variables from __ARG_IN into the calling scope, so the variables are ready to be used by user-supplied function 
# generate_targets() or declare_dependencies()
function(_instantiate_variables __ARGS __ARGS_LIST)
	if(NOT __ARGS_LIST)
		return()
		message(FATAL_ERROR "No variables to instantiate")
	endif()
	foreach(__VAR IN LISTS __ARGS_LIST)
		set(${__VAR} "${${__ARGS}_${__VAR}}" PARENT_SCOPE)
	endforeach()
endfunction()

function(_make_instance_id __TEMPLATE_NAME __ARGS __OUT)
	get_property(__TEMPLATE_NAMES GLOBAL PROPERTY __TEMPLATE_NAMES_${__TEMPLATE_NAME})
	_calculate_hash(${__ARGS} "${${__ARGS}__LIST}" "" __HASH)
	if("${__HASH}" STREQUAL "")
		set(${__OUT} "${__TEMPLATE_NAME}")
	else()
		set(${__OUT} "${__TEMPLATE_NAME}_${__HASH}")
	endif()
	
	_serialize_variables(${__ARGS} __TMP_SER)
#	message(STATUS "_make_instance_id(): ${__TEMPLATE_NAME} with args ${__TMP_SER} got hash ${${__OUT}}")
	set(${__OUT} "${${__OUT}}" PARENT_SCOPE)
endfunction()

function(_make_instance_name __INSTANCE_ID __OUT)
#	message(STATUS "_make_instance_name(): called for __INSTANCE_ID: ${__INSTANCE_ID}")
	_get_target_behavior(__TARGET_BEHAVIOR)
	if("${__TARGET_BEHAVIOR}" STREQUAL "GATHERING_DEPENDENCIES")
		message(FATAL_ERROR "Internal error. Function _make_instance_name should never be called during gathering dependencies phase")
	endif()
	
	
	_retrieve_instance_data(${__INSTANCE_ID} INSTANCE_NAME __INSTANCE_NAME)
	if(__INSTANCE_NAME)
		set(${__OUT} ${__INSTANCE_NAME} PARENT_SCOPE)
		return()
	endif()
	
	_retrieve_instance_args(${__INSTANCE_ID} __ARGS)
	_retrieve_instance_data(${__INSTANCE_ID} MODIFIERS __ARGS__LIST_MODIFIERS)
	_calculate_hash(__ARGS "${__ARGS__LIST_MODIFIERS}" "" __HASH)
#	message(STATUS "_make_instance_name(): ${__TEMPLATE_NAME} got hash ${__HASH}")
	_retrieve_instance_data(${__INSTANCE_ID} TEMPLATE __TEMPLATE_NAME)
	if(NOT __TEMPLATE_NAME)
		message(FATAL_ERROR "Internal error: cannot retrieve TEMPLATE_NAME from INSTANCE_ID ${__INSTANCE_ID}")
	endif()
	_retrieve_instance_data(${__INSTANCE_ID} TARGET_FIXED __IS_TARGET_FIXED)
	
	_get_number_of_instance_modifier_hashes(${__TEMPLATE_NAME} __NUMBER_OF_TARGETS)
	
	get_property(__TEMPLATE_NAMES GLOBAL PROPERTY __TEMPLATE_NAMES_${__TEMPLATE_NAME})
	if(NOT __IS_TARGET_FIXED)
		string(TOLOWER ${__TEMPLATE_NAME} __TEMPLATE_NAME_SMALL)
	else()
		set(__TEMPLATE_NAME_SMALL "${__TEMPLATE_NAME}")
	endif()
	string(REPLACE "::" "__" __TEMPLATE_NAME_VAR "${__TEMPLATE_NAME}")
	if("${__NUMBER_OF_TARGETS}" GREATER "1")
		if( "${__HASH}" IN_LIST __TEMPLATE_NAMES)
			list(FIND __TEMPLATE_NAMES "${__HASH}" __LENGTH_P1 )
			set(__TMP "${__TEMPLATE_NAME_SMALL}")
		else()
			if(__IS_TARGET_FIXED)
				message(FATAL_ERROR "Target ${__TEMPLATE_NAME} is fixed, which means you can't have two versions of ${__TEMPLATE_NAME} in one build.")
			endif()
			list(LENGTH __TEMPLATE_NAMES __LENGTH)
			math(EXPR __LENGTH_P1 "${__LENGTH} + 1")
			set_property(GLOBAL APPEND  PROPERTY __TEMPLATE_NAMES_${__TEMPLATE_NAME_VAR} "${__HASH}" )
			set(__TMP "${__TEMPLATE_NAME_SMALL}${__LENGTH_P1}")
		endif()
	else()
		set(__TMP "${__TEMPLATE_NAME_SMALL}")
		set_property(GLOBAL APPEND  PROPERTY __TEMPLATE_NAMES_${__TEMPLATE_NAME_VAR} "${__HASH}" )
	endif()
#	message(STATUS "_make_instance_name(): ${__TEMPLATE_NAME} with hash ${__HASH} got its instance name ${__TMP}")
	set(${__OUT} "${__TMP}" PARENT_SCOPE)
	_store_instance_target(${__INSTANCE_ID} ${__TMP}  )
endfunction()

function(_make_cmake_args __PARS __ARGS __ARGS_LIST __OUT_CMAKE_ARGS)
#	message(STATUS "_make_cmake_args(): __PARS: ${__PARS} __ARGS: ${__ARGS} __ARGS_LIST: ${__ARGS_LIST}")
	set(__CMAKE_ARGS)
	foreach(__VAR IN LISTS __ARGS_LIST)
#		message(STATUS "_make_cmake_args(): processing ${__ARGS}_${__VAR}. Container ${__PARS}_${__VAR}__CONTAINER: ${${__PARS}_${__VAR}__CONTAINER}") # Container ${__PARS}_${__VAR}_CONTAINER: ${${__PARS}_${__VAR}_CONTAINER}, ${__PARS}_${__VAR}_TYPE: ${{__PARS}_${__VAR}_TYPE}
		if("${${__PARS}_${__VAR}__CONTAINER}" STREQUAL "OPTION" )	
			if(${__ARGS}_${__VAR})
				list(APPEND __CMAKE_ARGS "-D${__VAR}:BOOL=ON")
			else()
				list(APPEND __CMAKE_ARGS "-D${__VAR}:BOOL=OFF")
			endif()
		elseif("${${__PARS}_${__VAR}__TYPE}" STREQUAL "INTEGER")
			list(APPEND __CMAKE_ARGS "-D${__VAR}:STRING=${${__ARGS}_${__VAR}}")
		elseif("${${__PARS}_${__VAR}__TYPE}" STREQUAL "BOOL")
			list(APPEND __CMAKE_ARGS "-D${__VAR}:BOOL=${${__ARGS}_${__VAR}}")
		else()
			message(FATAL_ERROR "Unknown way to pass an argument ${__VAR} into the cmake, because it is ${${__PARS}_${__VAR}__CONTAINER} of type ${${__PARS}_${__VAR}__TYPE}")
		endif()
	endforeach()
#	message(STATUS "_make_cmake_args(): finished processing. ${__OUT_CMAKE_ARGS}: ${__CMAKE_ARGS}") 
	set(${__OUT_CMAKE_ARGS} "${__CMAKE_ARGS}" PARENT_SCOPE)
endfunction()

#Function ignores information about which parameters are modifiers.
function(_serialize_variables __ARGS __OUT_SERIALIZED)
	set(OUT)
#	message(STATUS "Serializing variables: ${${__ARGS}__LIST}...")
	foreach(__VAR IN LISTS ${__ARGS}__LIST)
		string(REPLACE ";" ":" ${__ARGS}_${__VAR} "${${__ARGS}_${__VAR}}")
		if(OUT)
			set(OUT "${OUT};")
		endif()
		set(OUT "${OUT}${__VAR};${${__ARGS}_${__VAR}}")
	endforeach()
	set(${__OUT_SERIALIZED} "${OUT}" PARENT_SCOPE)
#	message(STATUS "... serialized string: \"${OUT}\"")
endfunction()

#Function ignores information about which parameters are modifiers.
function(_serialize_parameters __PARS __OUT_SERIALIZED)
	set(OUT)
#	message(STATUS "Serializing variables: ${${__ARGS}__LIST}...")
	foreach(__PAR IN LISTS ${__PARS}__LIST)
		if(OUT)
			set(OUT "${OUT};")
		endif()
		set(OUT "${OUT}${__PAR};${${__PARS}_${__PAR}__CONTAINER};${${__PARS}_${__PAR}__TYPE}")
	endforeach()
	set(${__OUT_SERIALIZED} "${OUT}" PARENT_SCOPE)
#	message(STATUS "... serialized string: \"${OUT}\"")
endfunction()

function(_unserialize_variables __SERIALIZED __OUT_ARGS)
	set(__LIST)
	if(__SERIALIZED)
#		message(STATUS "_unserialize_variables, __SERIALIZED: ${__SERIALIZED} ")
		list(LENGTH __SERIALIZED __TMP)
		math(EXPR __ARGS_LENGTH "${__TMP} / 2 - 1")
		math(EXPR __ARGS_CHECK "${__TMP} % 2")
		if(NOT "${__ARGS_CHECK}" STREQUAL "0")
			message(FATAL_ERROR "Wrong number of elements in the serialized arguments ${__SERIALIZED}. Expected number of elements divisible by 2, but got ${__TMP} elements.")
		endif()

		foreach(__VAR_NR RANGE "${__ARGS_LENGTH}")
			math(EXPR __TMP "${__VAR_NR}*2")
			list(GET __SERIALIZED ${__TMP} __VARNAME)
			list(APPEND __LIST ${__VARNAME})
		
			math(EXPR __TMP "${__VAR_NR}*2 + 1")
			list(GET __SERIALIZED ${__TMP} __VALUE)
			string(REPLACE ":" ";" __VALUE "${__VALUE}")
			set(${__OUT_ARGS}_${__VARNAME} "${__VALUE}" PARENT_SCOPE)
		endforeach()
	endif()
	set(${__OUT_ARGS}__LIST "${__LIST}" PARENT_SCOPE)
endfunction()

function(_unserialize_parameters __SERIALIZED __OUT_PARS)
	set(__LIST)
	if(__SERIALIZED)
#		message(STATUS "_unserialize_parameters(): __SERIALIZED: ${__SERIALIZED} ")
		list(LENGTH __SERIALIZED __TMP)
		math(EXPR __PARS_LENGTH "${__TMP} / 3 - 1")
		math(EXPR __PARS_CHECK "${__TMP} % 3")
		if(NOT "${__PARS_CHECK}" STREQUAL "0")
			message(FATAL_ERROR "Wrong number of elements in the serialized arguments ${__SERIALIZED}. Expected number of elements divisible by 2, but got ${__TMP} elements.")
		endif()
		foreach(__PAR_NR RANGE "${__PARS_LENGTH}")
			math(EXPR __TMP "${__PAR_NR}*3")
			list(GET __SERIALIZED ${__TMP} __VARNAME)
			list(APPEND __LIST ${__VARNAME})
		
			math(EXPR __TMP "${__PAR_NR}*3 + 1")
			list(GET __SERIALIZED ${__TMP} __CONTAINER)
			set(${__OUT_PARS}_${__VARNAME}__CONTAINER "${__CONTAINER}" PARENT_SCOPE)

			math(EXPR __TMP "${__PAR_NR}*3 + 2")
			list(GET __SERIALIZED ${__TMP} __TYPE)
			set(${__OUT_PARS}_${__VARNAME}__TYPE "${__TYPE}" PARENT_SCOPE)
#			message(STATUS "_unserialize_parameters(): __VARNAME: ${__VARNAME}, __CONTAINER: ${__CONTAINER}, __TYPE: ${__TYPE}")
		endforeach()
	endif()
	set(${__OUT_PARS}__LIST "${__LIST}" PARENT_SCOPE)
#	message(STATUS "_unserialize_parameters(): ${__OUT_PARS}__LIST: ${__LIST}")
endfunction()

