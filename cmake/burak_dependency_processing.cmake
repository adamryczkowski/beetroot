
# Function that calls declare_dependencies() and gathers all dependencies into the global storage. The dependency information is sufficient to properly call generate_target() or apply_to_target() user functions.
function(_discover_dependencies __TEMPLATE_NAME __TARGETS_CMAKE_PATH __ARGS __ARGS_LIST __OUT_INSTANCE_IDS )
	message(STATUS "Discovering dependencies for ${__TEMPLATE_NAME}...")
#	_read_targets_file("${__TARGETS_CMAKE_PATH}" __READ __IS_TARGET_FIXED)
	_instantiate_variables(${__ARGS} "${__ARGS_LIST}")

	_descend_dependencies_stack()
	declare_dependencies(${__TEMPLATE_NAME}) #May call get_target() which will call _discover_dependencies() recursively
#	message(FATAL_ERROR "__ARGS_LIST: ${__ARGS_LIST}")
	_get_dependencies_from_stack(__DEP_INSTANCE_IDS)
	_ascend_dependencies_stack()
	set(${__OUT_INSTANCE_IDS} "${__DEP_INSTANCE_IDS}" PARENT_SCOPE)
endfunction()

#Instantiates target. The function is called during the target building phase. Behavior is different on SUPERBUILD and in the project build.
function(_instantiate_target __INSTANCE_ID)
	_get_target_behavior(__TARGET_BEHAVIOR)
	if(NOT "${__TARGET_BEHAVIOR}" STREQUAL "DEFINING_TARGETS")
		message(FATAL_ERROR "Burak internal error: _get_dependencies() called when not DEFINIG_TARGETS")
	endif()
	_retrieve_all_instance_data(${__INSTANCE_ID} __ARGS __DEP_IDS __TEMPLATE_NAME __TARGETS_CMAKE_PATH __IS_TARGET_FIXED  __EXTERNAL_PROJECT_INFO __IS_TARGET_REQUIRED __TEMPLATE_OPTIONS)
#	message(STATUS "_instantiate_target(): Retrieved data for ${__TEMPLATE_NAME}. __EXTERNAL_PROJECT_INFO: ${__EXTERNAL_PROJECT_INFO}")
#	if("${__TEMPLATE_NAME}" STREQUAL "SerialboxStatic")
#		message(FATAL_ERROR "__INSTANCE_ID: ${__INSTANCE_ID} __EXTERNAL_PROJECT_INFO: ${__EXTERNAL_PROJECT_INFO}")
#	endif()
	_make_instance_name(${__INSTANCE_ID} __INSTANCE_NAME)
#	message(STATUS "_instantiate_target(): Named ${__INSTANCE_ID}: ${__INSTANCE_NAME}")
	set(__DEP_TARGETS)
	if(__DEP_IDS)
		foreach(__DEP_ID IN LISTS __DEP_IDS)
			_instantiate_target(${__DEP_ID})
			if(__DEP_TARGET_NAME)
				list(APPEND __DEP_TARGETS ${__DEP_TARGET_NAME})
			endif()
		endforeach()
		
		message(STATUS "Gathered the following dependencies for ${__INSTANCE_NAME}: ${__DEP_TARGETS}")
	endif()
#	message(STATUS "Entry to _instantiate_target, __TEMPLATE_NAME: ${__TEMPLATE_NAME}, __TARGETS_CMAKE_PATH=${__TARGETS_CMAKE_PATH}. Dependencies: ${__DEP_LIST} ")
	if(NOT __NOT_SUPERBUILD)
		string(REPLACE "::" "_" __INSTANCE_NAME ${__INSTANCE_NAME})
	endif()
	if(NOT TARGET "${__INSTANCE_NAME}")
		_make_instance_name(${__INSTANCE_ID} __INSTANCE_NAME)
		if(__EXTERNAL_PROJECT_INFO)
			#Handling external project
			_retrieve_instance_pars(${__INSTANCE_ID} __PARS)
#								__TEMPLATE_NAME 	__INSTANCE_NAME 		__TEMPLATE_DIR __PARS_PREFIX __ARGS_PREFIX __EXTERNAL_PROJECT_ARGS __DEPENDENCIES_ID
			_retrieve_instance_data(${__INSTANCE_ID} MODIFIERS_HASHES __HASH)
			_retrieve_instance_data(${__INSTANCE_ID} MODIFIERS __ARGS__LIST_MODIFIERS)
			_get_target_external(${__TEMPLATE_NAME} ${__INSTANCE_NAME} "${__TARGETS_CMAKE_PATH}" __PARS __ARGS "${__ARGS__LIST_MODIFIERS}"  "${__EXTERNAL_PROJECT_INFO}" "${__DEP_TARGETS}" "${__HASH}")
		else()
			if(__NOT_SUPERBUILD) # We ignore internal dependencies on SUPERBUILD phase
#				message(STATUS "_instantiate_target(): Calling _get_target_internal(${__TEMPLATE_NAME} ${__INSTANCE_NAME} \"${__TARGETS_CMAKE_PATH}\" __ARGS)")
				_get_target_internal(${__INSTANCE_ID})
				if(NOT TARGET ${__INSTANCE_NAME} AND ${__IS_TARGET_REQUIRED})
					message(FATAL_ERROR "Template ${__TEMPLATE_NAME} did not produce a target")
				endif()
			endif()
		endif()
		
#		if(NOT "${__TEMPLATE_NAME}" STREQUAL "LIBHELLO")
#					message(FATAL_ERROR "__TEMPLATE_NAME: ${__TEMPLATE_NAME} __DEP_IDS: ${__DEP_IDS}")
#		endif()
		if(NOT __INSTANCE_NAME)
			message(FATAL_ERROR "No instance_name")
		endif()
#		message(STATUS "_instantiate_target(): __INSTANCE_NAME: ${__INSTANCE_NAME} __EXTERNAL_PROJECT_INFO: ${__EXTERNAL_PROJECT_INFO} __NOT_SUPERBUILD: ${__NOT_SUPERBUILD}")
		if(NOT (__EXTERNAL_PROJECT_INFO AND NOT __NOT_SUPERBUILD)) #We need to exclude dependency processing for external projects in the internal run.
			foreach(__DEP_INSTANCE_ID IN LISTS __DEP_IDS)
				_make_instance_name(${__DEP_INSTANCE_ID} __DEP_INSTANCE_NAME)
				if(NOT __DEP_INSTANCE_NAME)
					message(FATAL_ERROR "No instance_name")
				endif()
				if(TARGET ${__INSTANCE_NAME})
					_invoke_apply_to_target(${__DEP_INSTANCE_ID} ${__INSTANCE_ID} __FUNCTION_EXISTS)
#					message(FATAL_ERROR "__FUNCTION_EXISTS: ${__FUNCTION_EXISTS} __DEP_INSTANCE_NAME: ${__DEP_INSTANCE_NAME}")
					if(TARGET "${__DEP_INSTANCE_NAME}" AND NOT __FUNCTION_EXISTS)
#						message(WARNING "_instantiate_target(): about to call target_link_libraries:\n __INSTANCE_ID: ${__INSTANCE_ID} Linking ${__INSTANCE_NAME} to ${__DEP_INSTANCE_NAME}. __FUNCTION_EXISTS: ${__FUNCTION_EXISTS} ")
						target_link_libraries(${__INSTANCE_NAME} ${__DEP_INSTANCE_NAME})
					endif()
				else()
					_retrieve_instance_data(${__INSTANCE_ID} PATH __DEP_TARGETS_CMAKE_PATH)
					_make_sure_no_apply_to_target(${__DEP_TARGETS_CMAKE_PATH} ${__DEP_INSTANCE_NAME} ${__INSTANCE_NAME} )
				endif()
			endforeach()
		endif()
	endif()
endfunction()

