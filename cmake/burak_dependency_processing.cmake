
# Function that calls declare_dependencies() and gathers all dependencies into the global storage. The dependency information is sufficient to properly call generate_target() or apply_to_target() user functions.
function(_discover_dependencies __TEMPLATE_NAME __TARGETS_CMAKE_PATH __ARGS __ARGS_LIST __OUT_INSTANCE_IDS )
	message(STATUS "Discovering dependencies for ${__TEMPLATE_NAME}...")
#	_read_targets_file("${__TARGETS_CMAKE_PATH}" __READ __IS_TARGET_FIXED)
	_instantiate_variables(${__ARGS} "${__ARGS_LIST}")

	_descend_dependencies_stack()
	declare_dependencies(${__TEMPLATE_NAME}) #May call get_target() which will call _discover_dependencies() recursively
#	message(FATAL_ERROR "__ARGS_LIST: ${__ARGS_LIST}")
	_get_dependencies_from_stack(__DEP_INSTANCE_IDS)
#	message(STATUS "_discover_dependencies(): __TEMPLATE_NAME: ${__TEMPLATE_NAME} __DEP_INSTANCE_IDS: ${__DEP_INSTANCE_IDS}")
	_ascend_dependencies_stack()
	set(${__OUT_INSTANCE_IDS} "${__DEP_INSTANCE_IDS}" PARENT_SCOPE)
endfunction()

#Instantiates target. The function is called during the target building phase. Behavior is different on SUPERBUILD and in the project build.
function(_instantiate_target __INSTANCE_ID)
	_get_target_behavior(__TARGET_BEHAVIOR)
	if(NOT "${__TARGET_BEHAVIOR}" STREQUAL "DEFINING_TARGETS")
		message(FATAL_ERROR "Burak internal error: _get_dependencies() called when not DEFINIG_TARGETS")
	endif()
	
	_retrieve_instance_data(${__INSTANCE_ID} TARGET_BUILT __IS_TARGET_BUILT)
	if(__IS_TARGET_BUILT)
		return() #Nothing to do in this run
	endif()

	_make_instance_name(${__INSTANCE_ID} __TARGET_NAME)
#	message(STATUS "_instantiate_target(): Named ${__INSTANCE_ID}: ${__TARGET_NAME}")
	set(__DEP_TARGETS)
	_retrieve_instance_data(${__INSTANCE_ID} DEP_INSTANCES __DEP_IDS)

#	message(STATUS "_instantiate_target(): Named ${__INSTANCE_ID}: ${__TARGET_NAME}, __DEP_IDS: ${__DEP_IDS}")
	if(__DEP_IDS)
		foreach(__DEP_ID IN LISTS __DEP_IDS)
			_instantiate_target(${__DEP_ID})
			_make_instance_name(${__DEP_ID} __DEP_TARGET_NAME)
			if(NOT __NOT_SUPERBUILD) #On superbuild the only targets we care about are external projects
				_retrieve_instance_data(${__INSTANCE_ID} EXTERNAL_INFO __EXTERNAL_INFO) 
			else()
				set(__EXTERNAL_INFO "JUST_TO_FOOL_THE_NEXT_COMMAND_IN_THIS_LOOP") #We pretend that any target is external in the project build, to save few more commands in this loop.
			endif()
			if(__DEP_TARGET_NAME)
				if(__EXTERNAL_INFO)
					list(APPEND __DEP_TARGETS ${__DEP_TARGET_NAME})
				endif()
			endif()
		endforeach()
		
#		message(STATUS "_instantiate_target(): Gathered the following dependencies for ${__TARGET_NAME}: ${__DEP_TARGETS}")
	endif()
#	message(STATUS "Entry to _instantiate_target, __TEMPLATE_NAME: ${__TEMPLATE_NAME}, __TARGETS_CMAKE_PATH=${__TARGETS_CMAKE_PATH}. Dependencies: ${__DEP_LIST} ")
	if(NOT __NOT_SUPERBUILD)
		string(REPLACE "::" "_" __TARGET_NAME ${__TARGET_NAME})
	endif()
	
	_retrieve_instance_data(${__INSTANCE_ID} EXTERNAL_INFO __EXTERNAL_PROJECT_INFO)
	if(__EXTERNAL_PROJECT_INFO)
		#Handling external project
		_get_target_external(${__INSTANCE_ID} "${__DEP_TARGETS}")
	else()
		if(__NOT_SUPERBUILD) # We ignore internal dependencies on SUPERBUILD phase
#				message(STATUS "_instantiate_target(): Calling _get_target_internal(${__TEMPLATE_NAME} ${__TARGET_NAME} \"${__TARGETS_CMAKE_PATH}\" __ARGS)")
			_get_target_internal(${__INSTANCE_ID} __FUNCTION_EXISTS)
			foreach(__DEP_INSTANCE_ID IN LISTS __DEP_IDS)
				_make_instance_name(${__DEP_INSTANCE_ID} __DEP_TARGET_NAME)
				if(NOT __DEP_TARGET_NAME)
					message(FATAL_ERROR "No target name")
				endif()
				if(TARGET ${__TARGET_NAME})
					_invoke_apply_dependency_to_target(${__INSTANCE_ID} ${__DEP_INSTANCE_ID} __FUNCTION_EXISTS)
				else()
					message(FATAL_ERROR "Template that does not produce targets currently cannot have any dependencies")
				endif()
#				message(STATUS "_instantiate_target(): __TARGET_NAME: ${__TARGET_NAME} __DEP_TARGET_NAME: ${__DEP_TARGET_NAME} __FUNCTION_EXISTS: ${__FUNCTION_EXISTS}")
				if(NOT __FUNCTION_EXISTS)
					if(TARGET "${__DEP_TARGET_NAME}")
#						message(STATUS "_instantiate_target(): about to call target_link_libraries:\n __INSTANCE_ID: ${__INSTANCE_ID} Linking ${__TARGET_NAME} to ${__DEP_TARGET_NAME}. __FUNCTION_ABSENT: ${__FUNCTION_ABSENT} ")
						target_link_libraries(${__TARGET_NAME} ${__DEP_TARGET_NAME})
					else()
						_retrieve_instance_data(${__DEP_INSTANCE_ID} _I_TEMPLATE_NAME __DEP_TEMPLATE_NAME )
						message(FATAL_ERROR "${__DEP_TEMPLATE_NAME} does not produce targets and it does not define apply_dependency_to_target(). You must either define targets or define function apply_dependency_to_target().")
					endif()
				endif()
			endforeach()
		endif()
	endif()
	_retrieve_instance_data(${__INSTANCE_ID} FEATUREBASE __FEATUREBASE_ID)
	_set_property_to_db(FEATUREBASEDB ${__FEATUREBASE_ID} TARGET_BUILT 1)
endfunction()

